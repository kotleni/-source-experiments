// Copyright (C) 1997-2006 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//  Alias Script File
//  MODIFY THIS AT YOUR OWN RISK
//
//  Creation Date:  Dec 3, 1996
//
//
//  Description:
//      This script describes the contents of the context sensitive menus.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//

proc optionalDagMenuProc( string $parent, string $item )
{
	// Look at the shape child of this object
	//
	string $object[] = `listRelatives -path -s $item`;

	string $shape = "";
	int $gotVisible = 0;

	if( size($object) < 1 ) return;

	for( $i=0; $i<size($object); $i+=1) {
		if( (0 == getAttr($object[$i] + ".io")) &&
			getAttr($object[$i] + ".v") ) {
			$shape = $object[$i];
			$gotVisible = 1;
			break;
		}
	}

	if( !$gotVisible ) {
		for( $i=0; $i<size($object); $i+=1) {
			if( 0 == getAttr($object[$i] + ".io")) {
				$shape = $object[$i];
				break;
			}
		}
	}

	if( "" != $shape ) {
		string $nt = `nodeType $shape`;
		switch( $nt ) {
		  case "subdiv":
			subdOptionalDagMenuProc( $parent, $item );
			menuItem -d true;
			break;

		  default:
			// Check to make sure we have a kPlugin prefix
			string $apiNt = `nodeType -api $shape`;
			if ( startsWith( $apiNt, "kPlugin" ) ) {
				string $nodeMenuCommand = $nt + "DagMenuProc";
				string $nodeMenuCommandWithArgs = $nodeMenuCommand + "(\"" + $parent + "\" , \"" + $item + "\" )";
				if ( exists( $nodeMenuCommand ) ) {
				   eval( $nodeMenuCommandWithArgs );
				}
			}
			break;
		}
	}
}

proc int objectIsTrimmed(string $item)
// Return true if this is a trimmed surface
{
	string $command = ("getAttr -size " + $item + ".trimFace");
	int $trimCount = eval($command);

	return ($trimCount != 0);
}


proc string getControlledHandle(string $item)
{
	string $handle;
	if (size(`ls ($item+".ikBlend")`)) {
		string $connHandles[] =
			`listConnections -type ikHandle ($item+".ikBlend")`;
		if (size($connHandles)) {
			$handle = $connHandles[0];
		}
	}
	return $handle;
}

proc int isIKcontroller(string $item)
{
	string $handle = getControlledHandle($item);
	return (size($handle) > 0);
}

proc
createFBIKmenuItems(string $parent,
					string $item,
					string $ikReachModeLocation,
					string $keyBodyPartLocation,
					string $keyAllLocation,
					string $keySelectedLocation)
{
	string $reachKeyingMode = "Reach Mode:";
	if (!`optionVar -exists fbikKeyOption`) {
	    //3 == simple key
		optionVar -intValue fbikKeyOption 3;
	}
	int $rkm = `optionVar -q fbikKeyOption`;
	switch ($rkm)
	{
		case 1:
			$reachKeyingMode = $reachKeyingMode + " IK";
			break;
		case 2:
			$reachKeyingMode = $reachKeyingMode + " FK";
			break;
		case 3:
			$reachKeyingMode = $reachKeyingMode + " Simple";
			break;
	}

	menuItem -rp $ikReachModeLocation -label $reachKeyingMode
		-subMenu true
		-annotation (uiRes("m_dagMenuProc.kDetermineHowAnnot")) ;

		menuItem -rp "S" -label (uiRes("m_dagMenuProc.kIK"))
			-command FBIKReachKeyingOptionIK;

		menuItem -rp "N" -label (uiRes("m_dagMenuProc.kFK"))
			-command FBIKReachKeyingOptionFK;

		menuItem -rp "E" -label (uiRes("m_dagMenuProc.kSimpleNoReach"))
			-command FBIKReachKeyingOptionSimple;

	setParent -m $parent;

	string $bodyPartKeyingModeStr;
	int $bodyPartKeyingMode = 1; // 1 == full body
	if (`optionVar -exists keyFullBody`) {

		$bodyPartKeyingMode = `optionVar -query keyFullBody`;
	}
	else {
	    optionVar -intValue keyFullBody 1;
	}

	if($bodyPartKeyingMode == 1) { //full body
	    menuItem -label (uiRes("m_dagMenuProc.kKeyAllSel"))
		    -echoCommand true
		    -c ("optionVar -intValue keyFullBody 1; fbikDoSelectionChanged();headsUpDisplay -refresh HUDFbikKeyingMode;")
		    -rp $keyAllLocation
		    keyAllItem;
    }
    else {
	    menuItem -label (uiRes("m_dagMenuProc.kKeyAll"))
		    -echoCommand true
		    -c ("optionVar -intValue keyFullBody 1; fbikDoSelectionChanged();headsUpDisplay -refresh HUDFbikKeyingMode;")
		    -rp $keyAllLocation
		    keyAllItem;
    }

	if($bodyPartKeyingMode == 2) { //body part
	    menuItem -label (uiRes("m_dagMenuProc.kKeyBodyPartSel"))
		    -echoCommand true
		    -c ("optionVar -intValue keyFullBody 2; fbikDoSelectionChanged();headsUpDisplay -refresh HUDFbikKeyingMode;")
		    -rp $keyBodyPartLocation
		    keyBodyPartItem;
    }
    else {
	    menuItem -label (uiRes("m_dagMenuProc.kKeyBodyPart"))
		    -echoCommand true
		    -c ("optionVar -intValue keyFullBody 2; fbikDoSelectionChanged();headsUpDisplay -refresh HUDFbikKeyingMode;")
		    -rp $keyBodyPartLocation
		    keyBodyPartItem;
    }

	if($bodyPartKeyingMode == 3) { //key selected
	    menuItem -label (uiRes("m_dagMenuProc.kKeySelectedSel"))
		    -echoCommand true
		    -c ("optionVar -intValue keyFullBody 3; fbikDoSelectionChanged();headsUpDisplay -refresh HUDFbikKeyingMode;")
		    -rp $keySelectedLocation
		    keySelectedItem;
	}
	else {
	    menuItem -label (uiRes("m_dagMenuProc.kKeySelected"))
		    -echoCommand true
		    -c ("optionVar -intValue keyFullBody 3; fbikDoSelectionChanged();headsUpDisplay -refresh HUDFbikKeyingMode;")
		    -rp $keySelectedLocation
		    keySelectedItem;
    }
}
proc checkForSkinInfluenceItem(string $item, string $quadrant)
{
	int $isJoint = (nodeType($item) == "joint");

	// Check if the current context is the skinPaint context
	// and the the joint is connected to a skinCluster
	//
	string  $currContext = `currentCtx`;
	string  $currTool    = "";
	if(`contextInfo -ex $currContext`) {
		$currTool = `contextInfo -c $currContext`;
	}
	string $paintWeights = (uiRes("m_dagMenuProc.kPaintWeights"));
	if ( $currTool == "artAttrSkin" ) {
		string $whichTool = `artAttrCtx -q -whichTool $currContext`;
		if ( $whichTool == "skinWeights" )  {
			string $connL[] = `listConnections ($item+".worldMatrix")`;
			string $conn;
			for($conn in $connL) {
				if (`nodeType $conn` == "skinCluster")
				{
					// select the surface (not the joint) and set
					// the joint as the current influence
					//
					string $currSel[] = `ls -sl`;
					string $currSelString;
					if (size($currSel) > 0) {
						string $currObj;
						$currSelString = "select -r ";
						for ($currObj in $currSel) {
							$currSelString += ($currObj+" ");
						}
					}
					menuItem -label $paintWeights
						-echoCommand true
						-c ($currSelString+"; setSmoothSkinInfluence " + $item)
						-rp $quadrant
						paintWeightItem;
					break;
				}
			}
		}
	}		// menu for skinCluster paint
	// Check if the current context is the clusterPaint context
	// and the the joint is connected to a jointCluster
	//
	else if ( $isJoint && ($currTool == "artAttr") ) {
		string $whichTool = `artAttrCtx -q -whichTool $currContext`;
		if ( $whichTool == "general" )  {
			string $connL[] = `listConnections ($item+".worldMatrix")`;
			string $conn;
			for($conn in $connL) {
				if (`nodeType $conn` == "jointCluster")
				{
					string $artCommand = "artAttrCtx" ;
					string $attribute = "cluster." + $conn +  ".weights" ;
					menuItem -label $paintWeights
						-echoCommand true
						// the following command doesnot update the UI hence we use the next one
						//-c ("artAttrCtx -e -pas \"cluster." + $conn +  ".weights\" `currentCtx`")
						-c ("artSetToolAndSelectAttr( \"" + $artCommand + "\", \"" + $attribute + "\" )")
						-rp "N"
						paintWeightItem;
					break;
				}
			}
		}
	}
	// menu for joint-set paint
	// Check if the current context is the setPaint context
	// and the the joint is connected to a objectSet via jointCluster
	//
	else if ( $isJoint && ($currTool == "artSetPaint") ) {
		string $connL[] = `listConnections ($item+".worldMatrix")`;
		string $conn;
		for($conn in $connL) {
			if (`nodeType $conn` == "jointCluster") {
				string $connS[] = `listConnections ($conn+".message")`;
				for($set in $connS) {
					if (`nodeType $set` == "objectSet") {
						menuItem -label (uiRes("m_dagMenuProc.kPaintSetMembership"))
							-echoCommand true
							// the following command doesnot update the UI hence we use the next one
							//-c ("artSetPaintCtx -e -settomodify " + $set + " `currentCtx`")
							-c ("artSetPaintSelectSet( \"" + $set + "\" )")
							-rp "N"
							paintWeightItem;
						break;
					}
				}
			}
		}
	}
}

global proc string[] objectSelectMasks(string $item)
// Returns the component selection masks that apply to this object
{
	string $maskList[];
	string $shape = $item;
	int $i;

	// Look at the shape child of this object
	//
	string $object[] = `listRelatives -path -s $item`;

	int $gotVisible = 0;

	for ($i = 0; $i < size($object); ++$i) {
		if( (0 == getAttr($object[$i] + ".io")) &&
			getAttr($object[$i] + ".v") ) {
			$shape = $object[$i];
			$gotVisible = 1;
			break;
		}
	}

	if( !$gotVisible ) {
		for ($i = 0; $i < size($object); ++$i)
		{
			if (getAttr($object[$i] + ".io") == 0)
			{
				$shape = $object[$i];
				break;
			}
		}
	}

	string $nt = `nodeType $shape`;

	switch ($nt) {
		case "lattice":
			$maskList[0] = "latticePoint";
			break;
		case "locator":
			$maskList[0] = "locator";
			break;
		case "nurbsCurve":
			$maskList[0] = "curveParameterPoint";
			$maskList[1] = "controlVertex";
			$maskList[2] = "editPoint";
			$maskList[3] = "hull";
			break;
		case "nurbsSurface":
			$maskList[0] = "isoparm";
			$maskList[1] = "controlVertex";
			$maskList[2] = "surfaceParameterPoint";
			$maskList[3] = "hull";
			$maskList[4] = "surfaceFace";
			$maskList[5] = "surfaceUV";
			if (objectIsTrimmed($shape)) {
				$maskList[6] = "surfaceEdge";
			}
			break;
		case "mesh":
			$maskList[0] = "edge";
			$maskList[1] = "vertex";
			$maskList[2] = "facet";
			$maskList[3] = "puv";
			$maskList[4] = "pvf";
			break;
		case "joint":
			$maskList[0] = "joint";		// special case
			break;
		case "ikHandle":
			$maskList[0] = "ikHandle";	// special case
			break;
		case "hikEffector":
		// fall through
		case "hikFloorContactMarker":
			$maskList[0] = "hikEffector";	// special case
			break;
		case "particle":
			$maskList[0] = "particle";	// only one choice
			break;
		case "spring":
			$maskList[0] = "springComponent";	// only one choice
			break;
		case "subdiv":
 			$maskList[0] = "subdivMeshPoint";
 			$maskList[1] = "subdivMeshEdge";
 			$maskList[2] = "subdivMeshFace";
 			$maskList[3] = "subdivMeshUV";
			break;
	}

	if (isIKcontroller($item)) {
		$maskList[size($maskList)] = "ikfkHandle";
	}

	return $maskList;
}


global proc string dagMenuProc_selectionMask_melToUI( string $mel )
{
	string $result = $mel;

	switch ($mel)
	{
		case "latticePoint":
			$result = (uiRes("m_dagMenuProc.kLatticePoint"));
			break;
		case "locator":
			$result = (uiRes("m_dagMenuProc.kLocator"));
			break;
		case "controlVertex":
			$result = (uiRes("m_dagMenuProc.kControlVertex"));
			break;
		case "editPoint":
			$result = (uiRes("m_dagMenuProc.kEditPoint"));
			break;
		case "hull":
			$result = (uiRes("m_dagMenuProc.kHull"));
			break;
		case "isoparm":
			$result = (uiRes("m_dagMenuProc.kIsoparm"));
			break;
		case "subdivMeshEdge":
			// fall through
		case "edge":
			$result = (uiRes("m_dagMenuProc.kEdge"));
			break;
		case "subdivMeshPoint":
			// fall through
		case "vertex":
			$result = (uiRes("m_dagMenuProc.kVertex"));
			break;
		case "joint":
			$result = (uiRes("m_dagMenuProc.kJoint"));
			break;
		case "ikHandle":
			$result = (uiRes("m_dagMenuProc.kIkHandle"));
			break;
		case "hikEffector":
			$result = (uiRes("m_dagMenuProc.kHikEffector"));
			break;
		case "ikfkHandle":
			$result = (uiRes("m_dagMenuProc.kIkfkHandle"));
			break;
		case "surfaceUV":
			$result = (uiRes("m_dagMenuProc.kSurfaceUV"));
			break;
		case "surfaceParameterPoint":
			$result = (uiRes("m_dagMenuProc.kSurfacePoint"));
			break;
		case "curveParameterPoint":
			$result = (uiRes("m_dagMenuProc.kCurvePoint"));
			break;
		case "surfaceEdge":
			$result = (uiRes("m_dagMenuProc.kTrimEdge"));
			break;
		case "surfaceFace":
			$result = (uiRes("m_dagMenuProc.kSurfacePatch"));
			break;
		case "subdivMeshUV":
			// fall through
		case "puv":
			$result = (uiRes("m_dagMenuProc.kUV"));
			break;
		case "subdivMeshFace":
			// fall through
		case "facet":
			$result = (uiRes("m_dagMenuProc.kFace"));
			break;
		case "pvf":
			$result = (uiRes("m_dagMenuProc.kVertexFace"));
			break;
		case "particle":
			$result = (uiRes("m_dagMenuProc.kParticle"));
			break;
		case "springComponent":
			$result = (uiRes("m_dagMenuProc.kSpring"));
			break;
		default:
			uiToMelMsg( "dagMenuProc_selectionMask_melToUI", $mel, 1 );
			break;
	}

	return $result;
}

global proc createSelectMenuItems(string $parent, string $item)
// Create a menu that shows the dag parenting for this object
{
	string $maskList[] = `objectSelectMasks($item)`;

	string $radialPosition[];
	string $uiName;

	int $i;
	int $isNurbObject     = false;
	int $isPolyObject     = false;
	int $isLatticeObject  = false;
	int $isJointObject    = false;
	int $isHikEffector	  = false;
	int $isIkHandleObject = false;
	int $isIkFkHandleObject = false;
	int $isParticleObject = false;
	int $isSpringObject   = false;
	int $isSubdivObject   = false;
	int $isLocatorObject  = false;
	int $hasComponents	  = false;

	//	Comparing an element in an empty array will increase the array
	//	to accomodate that element.
	//
	//	To avoid this, first test the size of the array before comparing
	//	elements that may not exist.
	//
	if (1 <= size($maskList)) {
		$isLatticeObject = ($maskList[0] == "latticePoint");
		$isJointObject = ($maskList[0] == "joint");
		$isHikEffector = ($maskList[0] == "hikEffector");
		$isIkHandleObject = ($maskList[0] == "ikHandle");
		$isParticleObject = ($maskList[0] == "particle");
		$isSpringObject = ($maskList[0] == "springComponent");
		$isSubdivObject = ($maskList[0] == "subdivMeshPoint");
		$isLocatorObject = ($maskList[0] == "locator");
	}
	if (2 <= size($maskList)) {
		$isNurbObject = ($maskList[1] == "controlVertex");
		$isPolyObject = ($maskList[1] == "vertex");
	}

	// $maxRadialPos keeps track of how many octants of the
	// RMB marking menu will be populated
	//
	int $maskSize = size($maskList);
	int $maxRadialPos = size($maskList);

	if (($maskSize > 0) && ($maskList[$maskSize-1] == "ikfkHandle")) {
		$isIkFkHandleObject = true;
		$maxRadialPos--; // ikfkHandle does not populate like other masks
	}

	$hasComponents = $isLatticeObject ||
					 $isParticleObject ||
					 $isSubdivObject ||
					 $isSpringObject ||
					 $isNurbObject ||
					 $isPolyObject;

	// NOTE:
	//			If the object has selectable components, then the
	//		radial position "NE" will be used for the menuItem:
	//		"Revert back to object mode."
	//
	setParent -menu $parent;
	$radialPosition[0] = "N";
	$radialPosition[1] = "W";
	$radialPosition[2] = "S";
	$radialPosition[3] = "E";
	$radialPosition[4] = "SW";
	$radialPosition[5] = "SE";
	$radialPosition[6] = "NW";
	$radialPosition[7] = "NE";

    string $disableikHandle = (uiRes("m_dagMenuProc.kDisableIkHandle"));
    string $enableIkHandle  = (uiRes("m_dagMenuProc.kEnableIkHandle"));
	string $setPreferred	= (uiRes("m_dagMenuProc.kSetPreferredAngle"));
	string $assumePreferred = (uiRes("m_dagMenuProc.kAssumePreferredAngle"));

	if ($isNurbObject) {
		for ($i = 0; $i < size($maskList); $i++) {
			  $uiName = `dagMenuProc_selectionMask_melToUI $maskList[$i]`;
			if ($maskList[$i] != "ikfkHandle") {
				menuItem -label $uiName
					-ecr false
					-c ( "doMenuNURBComponentSelection(\"" +
						 $item + "\", \"" +  $maskList[$i] + "\")")
					-rp $radialPosition[$i];
			}
		}

		// Check if the current context is the skinPaint context
		// and the the nurbs is connected to a skinCluster. If so, add
		// Paint Skin Weights to north ("NW") quadrant
		//
		checkForSkinInfluenceItem($item, "NW");

	} else if ($isPolyObject) {
		for ($i = 0; $i < size($maskList); $i++) {
				$uiName = `dagMenuProc_selectionMask_melToUI $maskList[$i]`;
			if ($maskList[$i] != "ikfkHandle") {
				menuItem -label $uiName
					-ecr false
					-c ( "doMenuComponentSelection(\"" +
						 $item + "\", \"" +  $maskList[$i] + "\")")
					-rp $radialPosition[$i];
			}
		}

		// Check if the current context is the skinPaint context
		// and the the poly is connected to a skinCluster. If so, add
		// Paint Skin Weights to north ("NW") quadrant
		//
		checkForSkinInfluenceItem($item, "NW");

	} else if ($isLatticeObject) {
		for ($i = 0; $i < size($maskList); $i++) {
			if ($maskList[$i] != "ikfkHandle") {
				$uiName = `dagMenuProc_selectionMask_melToUI $maskList[$i]`;
				menuItem -label $uiName
					-ecr false
					-c ( "doMenuLatticeComponentSelection(\"" +
						 $item + "\", \"" +  $maskList[$i] + "\")")
					-rp $radialPosition[$i];
			}
		}
	} else if ($isJointObject) {
		string $setCmd = `performSetPrefAngle 2`;
		string $assumeCmd = `performAssumePrefAngle 2`;
		$setCmd += (" "+$item);
		$assumeCmd += (" "+$item);
		string $jts[] = `ls -sl -type joint`;
		for ($jointItem in $jts) {
			if ($jointItem != $item) {
				$setCmd += (" "+$jointItem);
				$assumeCmd += (" "+$jointItem);
			}
		}
		menuItem -label $setPreferred
			-echoCommand true
			-c ($setCmd)
			-rp "N"
			setPrefAngleItem;

		menuItem -label $assumePreferred
			-echoCommand true
			-c ($assumeCmd)
			-rp "S"
			assumePrefAngleItem;

		string $hikHandle[] = `listConnections -type hikHandle $item`;
		int $isFBIKjoint = (size($hikHandle) > 0);
		if ($isFBIKjoint) {
			createFBIKmenuItems($parent, $item,"W","NE","E","SE");
		}

		// Check if the current context is the skinPaint context
		// and the the joint is connected to a skinCluster. If so, add
		// Paint Skin Weights to north ("N") quadrant
		//
		checkForSkinInfluenceItem($item, "N");

	} else if ($isHikEffector){
		if (nodeType($item) == "hikFloorContactMarker") {
			string $parentItems[] = `listRelatives -pa -p $item`;
			if (size($parentItems) &&
				nodeType($parentItems[0]) == "hikEffector") {
				$item = $parentItems[0];
			} else {
				$isHikEffector = false;
			}
		}

		if ($isHikEffector) {
		    string $pivotOffsetPlug = $item + ".pivotOffset";
		    float $pivotOffset[] = `getAttr $pivotOffsetPlug`;
		    int $enablePin = (equivalentTol($pivotOffset[0],0.0,0.001) &&
		                      equivalentTol($pivotOffset[1],0.0,0.001) &&
		                      equivalentTol($pivotOffset[2],0.0,0.001));

			// set pinning for hikEffectors
			menuItem -label (uiRes("m_dagMenuProc.kPinBoth"))
				-echoCommand true
				-c ("doPinHikEffectors 1 {\"3\",\"" + $item + "\"};")
				-enable $enablePin
				-rp "N"
				pinAllItem;

			menuItem -label (uiRes("m_dagMenuProc.kPinTranslate"))
				-echoCommand true
				-c ("doPinHikEffectors 1 {\"1\",\"" + $item + "\"};")
				-enable $enablePin
				-rp "NW"
				pinTransItem;

			menuItem -label (uiRes("m_dagMenuProc.kPinRotate"))
				-echoCommand true
				-c ("doPinHikEffectors 1 {\"2\",\"" + $item + "\"};")
				-enable $enablePin
				-rp "SW"
				pinRotItem;

			menuItem -label (uiRes("m_dagMenuProc.kUnpin"))
				-echoCommand true
				-c ("doPinHikEffectors 1 {\"0\",\"" + $item + "\"};")
				-rp "S"
				unpinItem;

			createFBIKmenuItems($parent, $item,"W","NE","E","SE");
		}
	} else if ($isLocatorObject) {
		// Check if the current context is the skinPaint context
		// and the the joint is connected to a skinCluster. If so, add
		// Paint Skin Weights to north ("N") quadrant
		//
		checkForSkinInfluenceItem($item, "N");

	} else if ($isIkHandleObject) {
		string $selectikHandlesJointsAnnot = (uiRes("m_dagMenuProc.kSelectikHandlesAnnot"));
		string $selectikHandlesAnnot = (uiRes("m_dagMenuProc.kEnableIKHandlesAnnot"));
		menuItem -label $setPreferred
			-annotation $selectikHandlesJointsAnnot
			-echoCommand true
			-c (`performSetPrefAngle 2` + " " + $item)
			-rp "W"
			setPrefAngleItem;

		menuItem -label $assumePreferred
			-annotation $selectikHandlesJointsAnnot
			-echoCommand true
			-c (`performAssumePrefAngle 2` + " " + $item)
			-rp "E"
			assumePrefAngleItem;

		menuItem -label $enableIkHandle
			-annotation $selectikHandlesAnnot
			-echoCommand true
			-c ("ikHandle -e -eh " + $item)
			-rp "N"
			enableIKHandlesItem;

		menuItem -label $disableikHandle
			-annotation $selectikHandlesAnnot
			-echoCommand true
			-c ("ikHandle -e -dh " + $item)
			-rp "S"
			disableIKHandlesItem;

		menuItem -label (uiRes("m_dagMenuProc.kEnableSnap"))
			-annotation $selectikHandlesAnnot
			-echoCommand true
			-c ("ikHandle -e -see " + $item + ";" +
				"ikHandle -e -shf on " + $item)
			-rp "SE"
			enableIKHandlesSnapItem;

		menuItem -label (uiRes("m_dagMenuProc.kDisableSnap"))
			-annotation $selectikHandlesAnnot
			-echoCommand true
			-c ("ikHandle -e -shf off " + $item)
			-rp "SW"
			disableIKHandlesSnapItem;

		$maxRadialPos = 6;
	} else if ($isParticleObject) {
		for ($i = 0; $i < size($maskList); $i++) {
			   $uiName = `dagMenuProc_selectionMask_melToUI $maskList[$i]`;
			menuItem -label $uiName
				-ecr false
				-c ( "doMenuParticleComponentSelection(\"" +
					$item + "\", \"" +  $maskList[$i] + "\")")
				-rp $radialPosition[$i];
		}
	} else if ($isSpringObject) {
		for ($i = 0; $i < size($maskList); $i++) {
			   $uiName = `dagMenuProc_selectionMask_melToUI $maskList[$i]`;
			menuItem -label $uiName
				-ecr false
				-c ( "doMenuSpringComponentSelection(\"" +
					$item + "\", \"" +  $maskList[$i] + "\")")
				-rp $radialPosition[$i];
		}
	} else if ($isSubdivObject) {
		subdDagMenuProc( 0, $item, $maskList );
	} else {
		for ($i = 0; $i < size($maskList); $i++) {
			if ($maskList[$i] == "ikfkHandle") {
				continue;
			}

			$uiName = `dagMenuProc_selectionMask_melToUI $maskList[$i]`;
			menuItem -label $uiName
				-ecr false
				-c ( "doMenuComponentSelection(\"" +
					$item + "\", \"" +  $maskList[$i] + "\")")
				-rp $radialPosition[$i];
		}
	}

	// If components are present, provide the ability to
	// get back to object mode...
	//
	if ($hasComponents) {
		menuItem -label (uiRes("m_dagMenuProc.kObjectMode"))
				-ecr false
				-c ( "hilite -unHilite " + $item + "; string $selection[] = `ls -sl`;"
					+ "changeSelectMode -object; select -r $selection;" )
				-rp "NE";
	}

	// Since any object can be an ikfk handle, we only populate the ikfk items
	// in slots that are not already in use.
	//
	if ($isIkFkHandleObject) {
		string $handle = getControlledHandle($item);

		if ($maxRadialPos < 8) {
			menuItem -label (uiRes("m_dagMenuProc.kSetIKFKKey"))
				-echoCommand true
				-annotation (uiRes("m_dagMenuProc.kSetKeysAnnot"))
				-rp $radialPosition[7]
				-command ("select -r "+$item+"; SetIKFKKeyframe");
		}

		if ($maxRadialPos < 7) {
			menuItem -label (uiRes("m_dagMenuProc.kMoveIKToFK"))
				-echoCommand true
				-annotation (uiRes("m_dagMenuProc.kSelectAnIKHandleOrIKFKAnnot"))
				-rp $radialPosition[6]
				-command ("select -r "+$item+"; MoveIKtoFK");
		}

		if ($maxRadialPos < 5) {
			menuItem -label $disableikHandle
				-annotation (uiRes("m_dagMenuProc.kDisableIKHandleAnnot"))
				-echoCommand true
				-c ("ikHandle -e -dh " + $handle)
				-rp $radialPosition[5];

			menuItem -label $enableIkHandle
				-annotation (uiRes("m_dagMenuProc.kEnableIKHandleAnnot"))
				-echoCommand true
				-c ("ikHandle -e -eh " + $handle)
				-rp $radialPosition[4];
		}
	}


//	for ($i = 0; $i < size($maskList); $i++) {
//       $itemName = "SELM" + string($i);
//			setParent -menu $parent;
//			menuItem
//				-c ("doMenuComponentSelection(\"" +
//					$item + "\", \"" +  $maskList[$i] + "\")")
//				-label $maskList[$i]
//				-rp $radialPosition[$i]
//				$itemName;
//	}
	setParent -menu $parent;
}

global proc doMenuNURBComponentSelection(string $item, string $mask)
//
// Change the selection/display state to allow selection of NURB components
//
{
	string $selectCmd;
	string $warn = (uiRes("m_dagMenuProc.kEditUVModeWarn"));

	if (`selectMode -q -object`) {
		hilite $item;
		selectType -ocm -alc false;
		$selectCmd = "selectType -ocm -" + $mask + " true;";

		// Test for implicit UVs - If we are in implicit UV mode
		// UVs are not selectable. So issue a warning.
		//
		if( $mask == "surfaceUV" )
		{
			int $isExplicit[] = `nurbsUVSet -q -ue $item`;
			if( !$isExplicit[0] )
			{
				warning(`format -s $item $warn`);
			}
		}
	} else {
		selectType -alc false;
		$selectCmd = "selectType -" + $mask + " true;";
		if (`selectMode -q -preset`) {
			$selectCmd = $selectCmd +"selectPriority -allComponents 1;";
			$selectCmd = $selectCmd +"selectPriority -isoparm 2;";
			$selectCmd = $selectCmd +"selectPriority -" + $mask + " 3;";
			switch ($mask) {
				case "surfaceUV":
					$selectCmd = $selectCmd +
						"toggle -state true -uv " + $item + ";";
					$selectCmd = $selectCmd +
						"toggle -state false -hull " + $item + ";";
					$selectCmd = $selectCmd +
						"toggle -state false -controlVertex " + $item + ";";
					$selectCmd = $selectCmd +
						"toggle -state false -editPoint " + $item + ";";

					// Test for implicit UVs - If we are in implicit UV mode
					// UVs are not selectable. So issue a warning.
					//
					int $isExplicit[] = `nurbsUVSet -q -ue $item`;
					if( !$isExplicit[0] )
					{
						warning(`format -s $item $warn`);
					}
					break;
				case "editPoint":
					$selectCmd = $selectCmd +
						"toggle -state true -" + $mask + " " + $item +";";
					$selectCmd = $selectCmd +
						"toggle -state false -hull " + $item + ";";
					$selectCmd = $selectCmd +
						"toggle -state false -controlVertex " + $item + ";";
					$selectCmd = $selectCmd +
						"toggle -state false -uv " + $item + ";";
					break;
				case "controlVertex":
					$selectCmd = $selectCmd +
						"toggle -state true -" + $mask + " " + $item +";";
					$selectCmd = $selectCmd +
						"toggle -state false -hull " + $item + ";";
					$selectCmd = $selectCmd +
						"toggle -state false -editPoint " + $item + ";";
					$selectCmd = $selectCmd +
						"toggle -state false -uv " + $item + ";";
					break;
				case "hull":
					$selectCmd = $selectCmd +
						"toggle -state true -" + $mask + " " + $item + ";";
					$selectCmd = $selectCmd +
						"toggle -state false -controlVertex " + $item + ";";
					$selectCmd = $selectCmd +
						"toggle -state false -editPoint " + $item + ";";
					$selectCmd = $selectCmd +
						"toggle -state false -uv " + $item + ";";
					break;
				default:
					$selectCmd = $selectCmd +
						"toggle -state false -hull " + $item + ";";
					$selectCmd = $selectCmd +
						"toggle -state false -controlVertex " + $item + ";";
					$selectCmd = $selectCmd +
						"toggle -state false -editPoint " + $item + ";";
					$selectCmd = $selectCmd +
						"toggle -state false -uv " + $item + ";";
					break;
			}
		} else {
			$selectCmd = $selectCmd + "hilite " + $item + ";";

			// Test for implicit UVs - If we are in implicit UV mode
			// UVs are not selectable. So issue a warning.
			//
			int $isExplicit[] = `nurbsUVSet -q -ue $item`;
			if( !$isExplicit[0] )
			{
			    warning(`format -s $item $warn`);
			}
		}
	}

	eval $selectCmd;
}

global proc doMenuLatticeComponentSelection(string $item, string $mask)
//
// Changes the selection/display state on this object to allow
// selection of the Lattice control points
{
	string $selectCmd;

	if (`selectMode -q -object`) {
		hilite $item;
		selectType -ocm -alc false;
		$selectCmd = "selectType -ocm -" + $mask + " true;";
	} else {
		selectType -ocm -alc false;
		$selectCmd = "selectType -" + $mask + " true;";
		if (!`selectMode -q -preset`) {
			$selectCmd = $selectCmd + "hilite " + $item + ";";
		} else {
			$selectCmd = $selectCmd + "toggle -" + $mask + ";";
		}
	}
	eval $selectCmd;
}


global proc doMenuParticleComponentSelection(string $item, string $mask)
//
// Change the selection/display state to allow selection of particle
// components
//
{
	string $selectCmd;

	if (`selectMode -q -object`) {
		hilite $item;
		selectType -ocm -alc false;
		$selectCmd = "selectType -ocm -" + $mask + " true;";
	} else {
		selectType -ocm -alc false;
		$selectCmd = "selectType -" + $mask + " true;";
		if (`selectMode -q -preset`) {
			$selectCmd = $selectCmd +"selectPriority -allComponents 1;";
			$selectCmd = $selectCmd +"selectPriority -particle 2;";
			$selectCmd = $selectCmd +"selectPriority -" + $mask + " 3;";
			switch ($mask) {
				case "particle":
					$selectCmd = $selectCmd +
						"toggle -state true -" + $mask + " " + $item +";";
					break;
				default:
					$selectCmd = $selectCmd +
						"toggle -state false -particle " + $item + ";";
					break;
			}
		} else {
			$selectCmd = $selectCmd + "hilite " + $item + ";";
		}
	}

	eval $selectCmd;
}


global proc doMenuSpringComponentSelection(string $item, string $mask)
//
// Change the selection/display state to allow selection of spring
// components
//
{
	string $selectCmd;

	if (`selectMode -q -object`) {
		hilite $item;
		selectType -ocm -alc false;
		$selectCmd = "selectType -ocm -" + $mask + " true;";
	} else {
		selectType -ocm -alc false;
		$selectCmd = "selectType -" + $mask + " true;";
		if (`selectMode -q -preset`) {
			$selectCmd = $selectCmd +"selectPriority -allComponents 1;";
			$selectCmd = $selectCmd +"selectPriority -springComponent 2;";
			$selectCmd = $selectCmd +"selectPriority -" + $mask + " 3;";
			switch ($mask) {
				case "springComponent":
					$selectCmd = $selectCmd +
						"toggle -state true -" + $mask + " " + $item +";";
					break;
				default:
					$selectCmd = $selectCmd +
						"toggle -state false -springComponent " + $item + ";";
					break;
			}
		} else {
			$selectCmd = $selectCmd + "hilite " + $item + ";";
		}
	}

	eval $selectCmd;
}


global proc doMenuComponentSelection(string $item, string $mask)
//
// Changes the selection/display state on this object to allow
// selection of the specified selection mask type.
{
	string $selectCmd;

	if (`selectMode -q -object`) {
		hilite $item;
		selectType -ocm -alc false;
		$selectCmd = "selectType -ocm -" + $mask + " true;";
	} else {
		selectType -ocm -alc false;
		$selectCmd = "selectType -" + $mask + " true;";
		if (!`selectMode -q -preset`) {
			$selectCmd = $selectCmd + "hilite " + $item + ";";
		}
	}
	eval $selectCmd;
}

global proc undoMenuComponentSelection(string $item, string $mask)
{
	string $selectCmd;

	if (`selectMode -q -object`) {
		$selectCmd = "selectType -ocm -" + $mask + " false;";
	} else {
		$selectCmd = "selectType -" + $mask + " false;";
	}

	eval $selectCmd;
}

global proc toggleBoundingBoxDisplay ( string $parent )
//
// For each shape under the selected parent object, toggle the
// state of bounding box display mode.
//
{
	string $shapes[] = `listRelatives -shapes $parent`;

	string $shape;

	for ( $shape in $shapes ) {
		int $overrideOn = `getAttr ( $shape + ".overrideEnabled")`;
		int $lodMode =    `getAttr ( $shape + ".overrideLevelOfDetail")`;
		int $enabled =     $overrideOn && $lodMode == 1;

		if ( $enabled ) {
			// Don't reset the overrideEnabled attribute. It
			// is used for more than just bounding box display
			// and turning if off will mess things up of you
			// have temporarily enabled bounding box display
			// of an object in a layer.
			setAttr ( $shape + ".overrideLevelOfDetail" ) 0;
		} else {
			setAttr ( $shape + ".overrideEnabled") 1;
			setAttr ( $shape + ".overrideLevelOfDetail") 1;
		}

	}
}

global proc createActionsMenuItems(string $parent, string $item)
//
// Creates a menu with common operations to perform on an object
//
{
	popupMenu -e -dai $parent;
	setParent -menu $parent;

	menuItem -label (uiRes("m_dagMenuProc.kTemplate"))  -c ("toggle -template -state on " + $item);
	menuItem -label (uiRes("m_dagMenuProc.kUntemplate"))  -c ("toggle -template -state off " + $item);
	menuItem -label (uiRes("m_dagMenuProc.kUnparent"))  -c ("parent -w " + $item);
	menuItem -label (uiRes("m_dagMenuProc.kBoundingBox"))  -c ("toggleBoundingBoxDisplay " + $item);
}


global proc showSG(string $item)
//
//	Display the Attribute Editor and show the tab for the
//	shading group that is on the object $item.
//
//  If would have been nicer to be able to use the
//	showShadingGroupAttributeEditor command, but it only
//  acts on the	selected object.
//
{
	//check selection list for faces (polys, subds, nurbs)
	string $shader = "";
	string $selection[] = `filterExpand -sm 34 -sm 38 -sm 72`;

	// If there are components selected, try to find a component shader
	if( size( $selection ) > 0)
	{
		string $nameBuffer[];

		int $numComps = size( $selection );
		int $comp;
		for( $comp = 0; $comp < $numComps; $comp++)
		{
			tokenize $selection[ $comp] "." $nameBuffer;

			//if the selected component is on the object under the pointer
			//get it's shader
			if ($nameBuffer[0] == $item) {
				$shader = `getComponentShader $selection[$comp]`;

				//check if the shader is already selected - only toggle
				//selection if it is not selected
				string $shaderSelected[] = `ls -selection $shader`;
				if ( size( $shaderSelected ) == 0){
					select -tgl $shader;

				}
				break;
			}
		}
	}

	// If we didn't find a component level shader, try for an object level one
	if( size( $shader ) == 0 ) {
		string $allNodes[] = (`listHistory -f true $item` );
		string $node = "";
		for ($node in $allNodes) {
			if(`nodeType $node` == "shadingEngine") {

				$shader = $node;
				break;
			}
		}
	}

	// If we found a shader, show it
	if( size( $shader ) > 0)
	{
		showEditor $shader;
	}
}

global proc showBakeSets(string $item, string $type)
//
//	Display the Attribute Editor and show the tab for the
//	first bake set of the specified $type that the object $item is in.
//  If there is no this $type of bake set in the scene, creates the
//  initial bake set of this type and show it in the attribute editor.
//
//  If would have been nicer to be able to use the
//	showBakeSetAttributeEditor command, but it only
//  acts on the	selected object.
//
{
	string $possibleBakeSets[] = (`listHistory -f true $item` );
	string $node = "";
    int $bakeSetExists = false;
	for ($node in $possibleBakeSets) {
		if(`nodeType $node` == $type)
        {
			showEditor $node;
            $bakeSetExists = true;
			break;
		}
	}

    // If no bake set exists for the $item, then create the
    // initial bake set of that $type and assign it to the $item.
    //
    if (!$bakeSetExists)
    {
        string $initialBakeSet = "";
		if($type == "vertexBakeSet")
        {
            $initialBakeSet = "initialVertexBakeSet";
        }
        else if($type == "textureBakeSet")
        {
            $initialBakeSet = "initialTextureBakeSet";
		}
        else
        {
            string $errorMsg = (uiRes("m_dagMenuProc.kBakeSetError"));
            error   -showLineNumber true
                (`format -s $type $errorMsg`);
            return;
        }

        // Create it if it does not exist yet.
        //
        if  ( size(`ls $initialBakeSet`) < 1)
        {
            createBakeSet($initialBakeSet, $type);
        }

        // Assign the initial bake set to the item.
        //
        assignBakeSet($initialBakeSet, $item);

        // Show the initial bake set.
        //
        showBakeSetAE($initialBakeSet);
    }
}

// Description:  This procedure is called to refresh the baking
//  attribute menu items.
//
global proc refreshBakingAttributeMenu (string $parent, string $item)
{
    setParent -menu $parent;

    int $suitable = bakeSetTypeSuitableForItem("textureBakeSet", $item);
    menuItem -edit -enable $suitable textureBakingAttributeItem;
    $suitable = bakeSetTypeSuitableForItem("vertexBakeSet", $item);
    menuItem -edit -enable $suitable vertexBakingAttributeItem;
}

// Description:  This procedure is called to create the
//  baking attribute menu.
//
proc createBakingAttributeMenu(string $parent, string $item)
{
    setParent -menu $parent;

	menuItem -label (uiRes("m_dagMenuProc.kEditAttributes"))
        -subMenu true
        -tearOff true
        -postMenuCommand ("refreshBakingAttributeMenu \""
                            +$parent+"|editAttributeItem\" \""
                            +$item+"\"")
        editAttributeItem;


        menuItem -label (uiRes("m_dagMenuProc.kTexture"))
            -c ("showBakeSets \""+$item+"\" \"textureBakeSet\"")
            textureBakingAttributeItem;
        menuItem -label (uiRes("m_dagMenuProc.kVertexMenuLabel"))
            -c ("showBakeSets \""+$item+"\" \"vertexBakeSet\"")
            vertexBakingAttributeItem;

    setParent -menu ..;
}

// Description:  This procedure is called to create the baking
//  menu items.
//
global proc createBakingMenuItems(string $parent, string $item)
//
//	Create the Baking menus for the RMB popup menu.
//
{
	popupMenu -e -deleteAllItems $parent;
	setParent -menu $parent;

    createBakingAttributeMenu($parent, $item);
	menuItem -d true;

	if (!`about -evalVersion`) {
		buildBakingMenus($item);
	}
}

// Description:  This procedure is called to create the switch proxy
//  menu items.
//
global proc createSwitchProxyMenuItems(string $parent, string $item, string $refNode)
//
//	Create the switch proxy submenu for the RMB popup menu.
//
{
	popupMenu -e -deleteAllItems $parent;
	setParent -menu $parent;

	string $proxyNodes[] = `getRelatedProxies $refNode`;
	int $i;
	string $proxyLabel;
	string $proxyTag;
	for( $i=0; $i<size($proxyNodes); $i+=1) {
		$proxyTag = `getAttr ($proxyNodes[$i] + ".proxyTag")`;

		menuItem -label $proxyTag -c ("proxySwitch " + $proxyNodes[$i]);
	}
}

global proc createHistoryMenuItems(string $parent, string $item)
//
// Creates a menu on the toolbar that shows a list of
// all operations that took place to create/modify
// the currently selected object.  Note that the list
// is not being filtered yet to get rid of things that
// users won't really care about, nor are the operations
// being listed as operations - their DG node names are
// simply being stuck into the menu.  This should
// change.
//
// Also note that the chain of operations limit is being
// hardcoded to 20 here, for the sake of speed.
//
{
	//
	// Delete all menu entries currently in the popup
	//
	popupMenu -e -dai $parent;
	setParent -menu $parent;

	historyPopupFill( $item, false, 1 );
}

global proc createFutureMenuItems(string $parent, string $item)
//
// Creates a menu on the toolbar that shows a list of
// all operations that took place to create/modify
// the currently selected object.  Note that the list
// is not being filtered yet to get rid of things that
// users won't really care about, nor are the operations
// being listed as operations - their DG node names are
// simply being stuck into the menu.  This should
// change.
//
// Also note that the chain of operations limit is being
// hardcoded to 20 here, for the sake of speed.
//
{
	//
	// Delete all menu entries currently in the popup
	//
	popupMenu -e -dai $parent;
	setParent -menu $parent;

	historyPopupFill( $item, true, 1 );
}

global proc string objectHandlesUvSets(string $item)
{
	string $maskList[];
	string $shape = $item;
	int $i;

	// Look at the shape child of this object
	//
	string $object[] = `listRelatives -path -s $item`;
	int $gotVisible = 0;

	for ($i = 0; $i < size($object); ++$i) {
		if( (0 == getAttr($object[$i] + ".io")) &&
			getAttr($object[$i] + ".v") ) {
			$shape = $object[$i];
			$gotVisible = 1;
			break;
		}
	}

	if( !$gotVisible ) {
		for ($i = 0; $i < size($object); ++$i)
		{
			if (getAttr($object[$i] + ".io") == 0)
			{
				$shape = $object[$i];
				break;
			}
		}
	}
	string $nt = `nodeType $shape`;

	if ($nt == "mesh")
		return $shape;
	return "";
}

global proc createUVsetMenuItems(string $parent, string $item,
								 string $shape)
{
	popupMenu -e -dai $parent;
	setParent -menu $parent;

	string $cmd = "polyUVSet -currentUVSet -uvSet ";
	string $curSetPI[] = `polyUVSet -q -currentPerInstanceUVSet $shape`;
	string $curSet[] = `polyUVSet -perInstance 1 -q -currentUVSet $shape`;
	string $names[] = `polyUVSet -perInstance true -q -allUVSets $shape`;
	int $numNames = size($names);
	for ($ii = 0; $ii < $numNames; $ii++) {
		string $perInst[] = `polyUVSet -uvSet $names[$ii] -q -pi $shape`;
		if (size($perInst) > 0 && size($perInst[0]) > 0) {
			$names[$ii] = $perInst[0];
		}
	}

	string $allProjects[] = `polyUVSet -pr -q $shape`;
	string $setClearCmd = "";
	if (size($allProjects))
	{
		$setClearCmd = "select -d ";
		for ($p=0; $p<size($allProjects); $p++)
			$setClearCmd += (" " + $allProjects[$p]);
		$setClearCmd += ";";
	}

	// Add in a menu to do uv-linking
	if ($numNames > 0)
	{
		string $ann = `getRunTimeCommandAnnotation "UVCentricUVLinkingEditor"`;
		string $cmd = "UVCentricUVLinkingEditor; " + "select -r " + $item;
		menuItem -label (uiRes("m_dagMenuProc.kUVLinking"))
			-c $cmd
			-annotation $ann;

		menuItem -label (uiRes("m_dagMenuProc.kUVSetEditor"))
			-c "UVSetEditor"
			-ann (getRunTimeCommandAnnotation("UVSetEditor"))
			;
		menuItem -divider true;
	}

	for ($i=0; $i<$numNames; $i++)
	{
		string $uvEditname = ("\"" + $names[$i] + "\"");
		string $uvname = $names[$i];
		string $setCurCmd = $cmd + $uvEditname + " " + $shape + ";";

		// Find any projections associated with the uvset
		string $projs[];
		$projs = `polyUVSet -pr -uvs $uvname -q $shape`;
		string $projCmd;

		// Add a divider between items
		if ($i > 0)
			menuItem -divider true;

		if ($uvname == $curSet[0] || $uvname == $curSetPI[0])
		{
			menuItem -label ($uvname) -c $setClearCmd -checkBox true;
			for ($j=0; $j<size($projs); $j++)
			{
				$projCmd = ($setClearCmd + "select -add "+ $projs[$j] + ";setToolTo ShowManips;");
				menuItem -label $projs[$j] -c $projCmd;
				if ($j >= 5)
					break;
			}
		}
		else
		{
			menuItem -label ($uvname) -c ($setClearCmd + $setCurCmd) -checkBox false;
			for ($j=0; $j<size($projs); $j++)
			{
				$projCmd = ($setCurCmd + $setClearCmd + "select -add "+ $projs[$j] + ";setToolTo ShowManips;");
				menuItem -label $projs[$j] -c $projCmd;
				if ($j >= 5)
					break;
			}
		}
	}
}

//
global proc string objectHandlesColorSets(string $item)
{
	string $maskList[];
	string $shape = $item;
	int $i;

	// Look at the shape child of this object
	//
	string $object[] = `listRelatives -path -s $item`;
	int $gotVisible = 0;

	for ($i = 0; $i < size($object); ++$i) {
		if( (0 == getAttr($object[$i] + ".io")) &&
			getAttr($object[$i] + ".v") ) {
			$shape = $object[$i];
			$gotVisible = 1;
			break;
		}
	}

	if( !$gotVisible ) {
		for ($i = 0; $i < size($object); ++$i)
		{
			if (getAttr($object[$i] + ".io") == 0)
			{
				$shape = $object[$i];
				break;
			}
		}
	}
	string $nt = `nodeType $shape`;

	if ($nt == "mesh")
		return $shape;

	return "";
}

global proc createColorSetMenuItems(string $parent, string $item,
								 string $shape)
{
	popupMenu -e -dai $parent;
	setParent -menu $parent;

	string $cmd = "polyColorSet -currentColorSet -colorSet ";
	string $curSet[] = `polyColorSet -q -currentColorSet $shape`;
	string $names[] = `polyColorSet -q -acs $shape`;
	string $rep[] = `polyColorSet -q -acs -representation $shape`;

	int $numNames = size($names);

	// Add in a menu to access color set editor
	menuItem -label (uiRes("m_dagMenuProc.kColorSetEditor"))
		-ann (getRunTimeCommandAnnotation("ColorSetEditor"))
		-command "colorSetEditor"
		;
	if ($numNames > 0)
	{
	menuItem -divider true;
	}

	for ($i=0; $i < $numNames; $i++)
	{
		string $colorEditname = ("\"" + $names[$i] + "\"");
		string $colorname = $names[$i];
		string $setCurCmd = $cmd + $colorEditname + " " + $shape + ";";

		// Add a divider between items
		if ($i > 0)
			menuItem -divider true;

		if ($colorname == $curSet[0])
		{
			$colorname += "(" + $rep[2*$i+1] + ")";
			menuItem -label ($colorname) -checkBox true;
		}
		else
		{
			$colorname += "(" + $rep[2*$i+1] + ")";
			menuItem -label ($colorname) -c ($setCurCmd) -checkBox false;
		}
	}
}

global proc createArtAttrMenuItems(
	string 		$parent,
	string 		$item
)
//
//	Description:
// 		Creates a menu that shows all the paintable attributes.
//
//	NOTE: paintAttr are sorted by the paintable node type.
//
{
	popupMenu -e -dai $parent;
	setParent -menu $parent;

	// add default items which are always displayed in the context menu
	menuItem -p $parent -label (uiRes("m_dagMenuProc.kPaintSelect"))  -command "ArtPaintSelectToolOptions" ;
	menuItem -p $parent -label (uiRes("m_dagMenuProc.kThreeDPaint"))  -command "Art3dPaintToolOptions" ;
	menuItem -p $parent -label (uiRes("m_dagMenuProc.kSculpt"))  -command "SculptGeometryToolOptions" ;

	// Get all paintable attributes
	string $paintAttr = `artBuildPaintMenu $item`;
	string $paint = (uiRes("m_dagMenuProc.kPaint"));

	if ($paintAttr != "")
	{
		// if the menu item has not been created, create it.
		if( $parent == "" )
			$parent = `menuItem -subMenu true -aob true -label $paint `;


		// create special purpose painting menu items for objects
		// such as cloth
		//
		string $excludeNodes[] = createPaintingMenuItems( $parent, $item );

		// Create the menu.
		artAttrCreateMenuItems( $parent, $paintAttr, $excludeNodes );

	}

	catch( vst_dagMenuProc() );
}

// This has been called because a menu press happened on a DAG object
// So find the Object submenu and add the DAG specific items to it.
//
global proc dagMenuProc(string $parent, string $object)
{
	global string $artSelectObject ;
	string $mode = "";

	if (`optionVar -exists currentMenuBarTab`) {
		$mode = `optionVar -q currentMenuBarTab`;
	} else {
		optionVar -sv currentMenuBarTab $mode;
	}

	if (`popupMenu -e -exists $parent`) {
		setParent -m $parent;

		// label the object
		string $shortName = `substitute ".*|" $object ""`;
		menuItem -label ($shortName + "...") -c ("showEditor "+$object);
		menuItem -divider true;
		menuItem -divider true;

		// Create the list of selection masks
		int $killStatus = 0;
		if( `objExists ( $object +".zooObjMenuDie" )` ) $killStatus = `getAttr ( $object +".zooObjMenuDie" )`;
		if( !$killStatus ) {
			createSelectMenuItems($parent, $object);
			menuItem -d true;
			}

		//if the node type is a skinner joint then see if there are any volumes under it...  if so, display the mirror volumes options
		int $addedVolItems = 0;
		if( `nodeType $object` == "vsSkinnerJoint" ) {
			menuItem -l "mirror volume hierarchy" -c( "{skinnerUtils; string $opp = `mirrorVolumeHierarchy \""+ $object +"\" \"\"`; select $opp; }" );
			$addedVolItems = 1;
			}
		if( `isOfType $object "vsSkinnerVol"` ) {
			menuItem -l "dupe and mirror around parent" -c( "{skinnerUtils; mirrorSelectedVolumesAroundParent 1; }" );
			menuItem -l "mirror around parent" -c( "{skinnerUtils; mirrorSelectedVolumesAroundParent 0; }" );
			$addedVolItems = 1;
			}
		if( $addedVolItems ) menuItem -d true;

		if( !$killStatus ) {
			menuItem -label (uiRes("m_dagMenuProc.kSelect"))  -c ("select -r " + $object);
			menuItem -label (uiRes("m_dagMenuProc.kSelectHierarchy"))  -c ("select -hierarchy " + $object);
			}

		//if the object is referenced display the remove ref edits option
		if( `referenceQuery -inr $object` ) menuItem -l( "remove ref edits selected" ) -c( "remEds `ls -sl` \"\";" );

		//if the object has parents display the xform to parnet option
		if( size(`listRelatives -p $object`)) menuItem -l "child xform to parent" -c( "{ zooAlign \"-load 1\"; for( $obj in `ls -sl` ) zooChildToParent $obj; }" );

    	menuItem -d true;

		//call the zooObjMenu script, to add any object specific commands to the rmb
		if( `zooObjMenu $parent $object` ) {
			return;
			}

		optionalDagMenuProc( $parent, $object );

		// create the history menu
		//
		string $menu = `menuItem -subMenu true -aob true -label (uiRes("m_dagMenuProc.kInputs")) `;
		menu -e
			-pmc ( "createHistoryMenuItems \""+$menu+"\" "+$object ) $menu;
		setParent -m $parent;

		$menu = `menuItem -subMenu true -aob true -label (uiRes("m_dagMenuProc.kOutputs")) `;
		menu -e -pmc ( "createFutureMenuItems \""+$menu+"\" "+$object ) $menu;
		setParent -m $parent;

	 	// Look at the shape child of this object
	 	//
 		string $shapes[] = `listRelatives -path -s $object`;

		// get current selection of shapes
		string $currentSel[] = `ls -sl -dagObjects -shapes` ;

		string $paintParent = "" ;
		int $selIndex  ;

 		int $i;
 		for ($i = 0; $i < size($shapes); ++$i)
		{
			string $nodeType = `nodeType $shapes[$i]` ;

			if ( ( $nodeType == "nurbsSurface") ||
				 ( $nodeType == "mesh") ||
				 ( $nodeType == "subdiv"))
			{
				// save the object name if it is not already selected by the user
				// We use this info to select the object if user chooses a paint option
				//
				// If user has selected multiple objects and is using context menu on one of them
				// we do not change the selection list as user may want to paint some attribute
				// on all of them. (It is the way it has been working all along...we don't want to
				// break it )

				int $found = 0 ;
				for( $selIndex  = 0 ; $selIndex  < size( $currentSel ); ++$selIndex  )
				{
					if( $shapes[$i] == $currentSel[ $selIndex  ] )
					{
						$found = 1 ;
						break ;
					}
				}

				if( $found )
				{
					$artSelectObject = "" ;
				}
				else
				{
					// check if the object is in component selection mode
					// and if it is, do not do any further selection.
					// We are assuming that if the object is in hilite mode
					// then the user is in component selection mode.

					$currentSel = `ls -hilite` ;
					for( $selIndex  = 0 ; $selIndex  < size( $currentSel ); ++$selIndex  )
					{
						if( $object == $currentSel[ $selIndex  ] )
						{
							$found = 1 ;
							break ;
						}
					}

					if( !$found )
						$artSelectObject = $object ;
					else
						$artSelectObject = "" ;
				}

				$paintParent = `menuItem -subMenu true -aob true -label (uiRes("m_dagMenuProc.kPaintSubmenu")) `;
				menu -e	-pmc ( "createArtAttrMenuItems \""+ $paintParent +"\" "+$object ) $paintParent ;
				setParent -m $parent;
				break ;
			}
		}

	    $menu = `menuItem -subMenu true -label (uiRes("m_dagMenuProc.kActions")) `;
		menu -e -pmc ( "createActionsMenuItems \""+$menu+"\" "+$object ) $menu;

		setParent -m $parent;

		// If the object can handle uv sets then add the uvset menu
		//
		string $shape = objectHandlesUvSets( $object );
		if ($shape != "")
		{
			$menu = `menuItem -subMenu true -label (uiRes("m_dagMenuProc.kUVSets")) `;
			menu -e
				-pmc ( "createUVsetMenuItems \""+$menu+"\" " +$object + " "+ $shape )
				$menu;
			setParent -m $parent;
		}

		string $shape = objectHandlesColorSets( $object );
		if ($shape != "")
		{
			$menu = `menuItem -subMenu true -label (uiRes("m_dagMenuProc.kColorSets")) `;
			menu -e
				-pmc ( "createColorSetMenuItems \""+$menu+"\" " +$object + " "+ $shape )
				$menu;
			setParent -m $parent;
		}

		// Shader menu to be able to quickly assign existing shaders
		// to the object under the pointer.
		//
    	menuItem -d true;

 		menuItem -label (uiRes("m_dagMenuProc.kMaterialAttributes")) -c ("showSG "+$object);

    	menuItem -d true;

        buildShaderMenus($object);

        menuItem -d true;

        menuItem -divider true;

        string $removeOverrideMenuItem = `menuItem
			-label (uiRes("m_dagMenuProc.kRemoveMaterialOverride"))
            -subMenu true`;
        menuItem -edit -postMenuCommand
            ("buildMaterialRemoveOverrideMenu -surface "+$object+" "+$removeOverrideMenuItem)
            $removeOverrideMenuItem;
        setParent -m ..;

		int $mentalIsLoaded = 0;
		string $renderer;
	    for ($renderer in `renderer -query -namesOfAvailableRenderers`) {
			if( $renderer == "mentalRay" ) {
				$mentalIsLoaded = 1;
				break;
			}
		}

		if ($mentalIsLoaded) {
 			$menu = `menuItem -subMenu true -label (uiRes("m_dagMenuProc.kBaking")) `;
 			menu -e
				-pmc ( "createBakingMenuItems \""+$menu+"\" "+$object )
				$menu;
 			setParent -m $parent;
		}

//		{
// 			$menu = `menuItem -subMenu true -label $paint `;
//			menu -e
//				-pmc ( "createPaintingMenuItems \""+$menu+"\" "+$object )
//				$menu;
// 			setParent -m $parent;
//		}

		if ($mode == "dynamicsMenuSet") {
			menuItem -d true;
			menuItem -label (uiRes("m_dagMenuProc.kConnectField"))  -c ("connectDynamic -f " + $object);
			menuItem -label (uiRes("m_dagMenuProc.kConnectEmitter"))  -c ("connectDynamic -em " + $object);
			menuItem -label (uiRes("m_dagMenuProc.kConnectCollision"))  -c ("connectDynamic -c " + $object);
		}

		// is there a reference associated with the object ?
		// and if so, is it in a loaded or unloaded state?
		string $refNode = `getRelatedReference $object`;
		if( size($refNode) > 0) {
			menuItem -d true;
			if( `file -rfn $refNode -q -dr` ) {
				menuItem -label (uiRes("m_dagMenuProc.kLoadRelatedReference"))  -c ("loadRelatedReference " + $object);
			} else {
				menuItem -label (uiRes("m_dagMenuProc.kReloadRelatedReference"))  -c ("loadRelatedReference " + $object);
				menuItem -label (uiRes("m_dagMenuProc.kUnloadRelatedReference"))  -c ("unloadRelatedReference " + $object);
			}
			// Is this reference a proxy? If so, add proxy switch submenu
			//
			string $proxyNodes[] = `getRelatedProxies $refNode`;
			if(size($proxyNodes) > 0) {
				$menu = `menuItem -subMenu true -label (uiRes("m_dagMenuProc.kReloadProxy")) `;
				menu -e
					-pmc ( "createSwitchProxyMenuItems \""+$menu+"\" "+$object + " " + $refNode )
					$menu;
				setParent -m $parent;
			}
		}

		setParent -m $parent;

	} else {
		string $warn = (uiRes("m_dagMenuProc.kMenuWarn"));
		warning(`format -s $parent $warn`);
	}
}
