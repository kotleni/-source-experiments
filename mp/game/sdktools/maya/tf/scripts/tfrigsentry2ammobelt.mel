/*source "C:\\dev\\main\\game\\sdktools\\maya\\7.0\\modules\\tf\\scripts\\tfRigSentry2Ammobelt.mel";tfRigSentry2Ammobelt ( 3, "turretMidControlR" ) ;source tfRigSentry2Ammobelt ;tfRigSentry2Ammobelt ( 3, "turretMidControlR", "P", 4.0, 1 ) ;{source tfRigSentry2Ammobelt;//right ammobeltselect -r Ref:ammochain08 ;tfRigSentry2Ammobelt ( 3, "turretMidControlR", "P", 4, 1 ) ;//left ammobeltselect -r Ref:ammoBeltL1 ;tfRigSentry2Ammobelt ( 3, "turretMidControlL", "P", 4, 1 ) ;//right wiresselect -r Ref:wirejointR01 ;tfRigSentry2Ammobelt ( 5, "turretBackControl", "C", 2, 1 ) ;//left wiresselect -r Ref:wirejointL01 ;tfRigSentry2Ammobelt ( 4, "turretBackControl", "C", 2, 1 ) ;//to ignore bindpose//skinCluster -mi 2 -omi false -tsb -ih -ibp ;}*/// jake nicholson, oct 2006// goal: create a splineIK rig from a joint chain, with specific desired behaviors// use:  sentry2MakeAmmobeltRig <number of controls> , <parent object of root control>, <vst display info ("L" "R" "P" "C")>, <control sphere radius>, <make expressions ("1" "0">//			<number of controls> = number of control objects, besides the 2 end controls, which control the spline.  must be <= number of joints - 1//			<parent object of root control> = parent object of the first control object//			<vst display info> = what vst display property to assign to the control objects.  "L" "R" "C" or "P"//			<control sphere radius> = radius of the control objects (they are spheres)//			<make expressions> = if "1", then it creates expressions on the duplicate joints which try to keep them fit to the curve when it changes length//			creates a "deploy" attribute on the first control, this successively scales (moves) the bones along the curve from the root.global proc tfRigSentry2Ammobelt( int $numControls, string $control1Parent, string $vstDisplay, float $ctrRad, int $makeExps ){	// duplicating the joint chain, renaming the duplicate with prefix "RigJoint_"	SelectHierarchy;	string $hierarchyRef[] = `ls -sl`;	//print $hierarchyRef;	//print $heirarchyRef[1];	//print `size($hierarchyRef)`;		duplicate -rr -n "tempname";	SelectHierarchy;	string $hierarchyRig[] = `ls -sl`;	//print (`size($hierarchyRef)` + "\n");	//print `size($hierarchyRig)`;			int $i;	int $num = size( $hierarchyRig );	for ( $i = 0; $i < $num; $i++ )	{		setAttr ($hierarchyRig[$i] + ".radius") 2;		//print ($hierarchyRig[$i]);		//print "\n";				//assuming Ref: namespace, removing that in this hacky way		int $j = `size $hierarchyRef[$i]`;		string $thisname = `substring  $hierarchyRef[$i] 5 $j` ;		//print ("thisname = " + $thisname + "\n");				rename $hierarchyRig[$i] ("RigJoint_" + $thisname);						$hierarchyRig[$i] = ("RigJoint_" + $thisname);			}//============================================================	//make the rigjoint chain a SplineIK//============================================================	string $splineIKoutput[] = `ikHandle -sj $hierarchyRig[0] -ee $hierarchyRig[($num - 1)] -sol ikSplineSolver -scv false -roc true -pcv false -ns 2` ;	//following ikHandle command output: Handle name, Effector name, Curve name		//print `size $splineIKoutput`;	//print ( "\nik reslut : " + $splineIKoutput[0] + "\n" ) ;	//print ( "ik reslut : " + $splineIKoutput[1] + "\n" ) ;	//print ( "ik reslut : " + $splineIKoutput[2] + "\n" ) ;		//constrain the ref chain to the corresponding rig chain	for ( $i = 0; $i < $num; $i++ )		{				parentConstraint -mo -weight 1 $hierarchyRig[$i] $hierarchyRef[$i];		}//================================================================================================================================================// make clusters for the spline cv's.//================================================================================================================================================string $curveName = $splineIKoutput[2] ;string $clustersArray[] ;string $tempGather[] ;// get number of cv's (degrees plus spans, according to help)int $numCVs = (`getAttr ( $curveName + ".degree") ` + `getAttr ( $curveName + ".spans") ` );//specify number of controls (not including the Start and End point controls)// moved this to arg in proc: int $numControls = 4;//$clustPop is total number of remaining CV's (other than the 2 CV's nearest each end) divided by the number of controls.  gives us the min (default) CV population of each clusterint $clustPop = ( ($numCVs - 4) / $numControls );//$clustRmd = remainder of above, so the number of clusters that will have 1 extra CV.int $clustRmd = `fmod ($numCVs - 4) $numControls` ;print ( "clustPop = : " + $clustPop + "\n" ) ;print ( "clustRmd = : " + $clustRmd + "\n" ) ;//now cluster the first and last set of 2 CVs$tempGather = `cluster -n Start ($curveName + ".cv[0:1]")` ;$clustersArray[0] = $tempGather[1] ;$tempGather = `cluster -n End ($curveName + ".cv[" + ( $numCVs - 2 ) + ":" + ( $numCVs - 1 ) + "]" )` ;$clustersArray[1] = $tempGather[1] ;//now cluster the restint $i;int $thisClustMin;int $thisClustMax;int $rmdShift = 0;string $thisClustName;for ( $i = 0; $i < $numControls; $i++ ){	$thisClustMin =  ( ( $i  ) * $clustPop ) + 2 + $rmdShift ;	$thisClustMax = ($thisClustMin + $clustPop -1 );			// if we have a remainder, then we need to add another CV to this cluster.		// decrement one from the remainder everytime we do this, and increment		// the total shift of the cluster min/max bounds per loop ($rmdShift)		if ( $clustRmd > 0 )		{			//print "rmd is still > 0 \n";			$thisClustMax++ ;			$rmdShift++ ;			$clustRmd-- ;		}		//print ("min control" + ( $i +1 ) + ": " + $thisClustMin + "\n");		//print ("max: " + $thisClustMax + "\n" ); 		//make the cluster		$thisClustName = ( "control" + ( $i + 1 ) ) ;		$tempGather = `cluster -n $thisClustName ( $curveName + ".cv[" + $thisClustMin + ":" + $thisClustMax + "]" )` ;		$clustersArray[ ( $i + 2 ) ] = $tempGather[1] ;	}print $clustersArray;//======================================================================//Creating the control objects, placed at each cluster//======================================================================string $controlsArray[] ;//get the array of clusters as names//select -r StartHandle EndHandle control1Handle control2Handle control3Handle ;//string $clustersArray[] = `ls -sl` ;float $clustPos[] ;for ( $i = 0; $i < `size $clustersArray`; $i++ ){	//not sure about this.  want teh global pos, using the -ws flag doestn give it to me.  i'm grabbing the local rotate pivot	//which i dont know what it is exactly, but the values are, in this case, it's global pos.  wtf?	$clustPos = `xform -q -rp $clustersArray[$i]` ;	//naming tomfoolery, this is hacky.  easy way to strip namespace? also, is misordered because i'm creating these based on $clustersArray, 	// which goes, 'first, last, second, third, etc' so the numbers are dum.	int $j = `size $hierarchyRef[$i]`;	string $thisname = ( `substring  $hierarchyRef[$i] 5 $j` + "_control" ) ;		$tempGather = `sphere -n $thisname -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r $ctrRad -d 3 -ut 0 -tol 0.01 -s 4 -nsp 3 ` ;	xform -t $clustPos[0] $clustPos[1] $clustPos[2] $tempGather[0] ;	$controlsArray[$i] = $tempGather[0] ;	vstSetDisplay ( $vstDisplay, $controlsArray[$i] );	//zero out the transforms	select -r $controlsArray[$i] ;	if ( $i == 0 ) 		{ 			if ( $control1Parent != "" )				{				parent $controlsArray [$i] $control1Parent ;				select -r $controlsArray[$i] ;			}		}	makeIdentity -apply true -t 1 -r 1 -s 0 -n 0;}//print "near end \n" ;//print $controlsArray ;//constrain the clusters to the control objectsfor ( $i = 0; $i < `size $controlsArray` ; $i++ )		{				parentConstraint -mo -weight 1 $controlsArray[$i] $clustersArray[$i];		}//===================================================================================================// try making expressions to stretch bones along curve when it's length changes.  this is a clumsy attempt//==================================================================================================={//declare the number of joints we'll be adding the expressions to.  need this to divide the added length over each joint//to try: maybe i should have points evenly distributed along the curve, and get linear dist between points to find what length to add to each bone.  would be more accurate//int $numJointExprs = 4 ; naw, just use all of the bones but the rootint $numJointExprs = ( `size $hierarchyRig` - 1 ) ;string $curveInfoNode = `arclen -ch on $curveName`;string $initClen = `arclen $curveName` ;string $thisJointName ;string $thisJointInit ;string $initClen ;int $HrigIndex ;//make a keyable attribute on the first control object that scales the bones along the curve, for snaking out from the gun on deploy//to try: have them scale in succession, not all at once accordian style.addAttr -ln deploy -at double -defaultValue 100.0 -minValue 0.0 -maxValue 100.0 -k on -r on $controlsArray[0];//main for loop.  the joints affected start with the last joint in $hierarchyRig[] //and then each joint up the chain until $numJointExprs is met.for ( $i = 0; $i < $numJointExprs ; $i++ ){	$HrigIndex = ( `size $hierarchyRig` - 1 - $i ) ;	print `size $hierarchyRig` ;	print ( "\n" + $HrigIndex + " is HrigIndex \n" ) ;	print $hierarchyRig[$HrigIndex] ;//gather the joint initialization info.  name and zpos at refpose$thisJointName = $hierarchyRig[$HrigIndex] ;string $thisJointInit = `getAttr ( $thisJointName + ".tz" ) ` ;//print $thisJointInit;//create the expressions...if ( $makeExps == 1 ){//works//expression -s ( ( $thisJointName + ".tz = " + $thisJointInit ) ) ;//works//expression -s ( ( $thisJointName + ".tz = " + $thisJointInit + " + " + $curveInfoNode + ".arcLength" ) ) ;//works//expression -s ( ( $thisJointName + ".tz = " + $thisJointInit + " + ( ( " + $curveInfoNode + ".arcLength - " + $initClen + " ) " + " / " + $numJointExprs + " ) " ) ) ;//works, but deployF doesnt ever change//expression -s ( ( $thisJointName + ".tz = " + $deployF + " * ( " + $thisJointInit + " + ( ( " + $curveInfoNode + ".arcLength - " + $initClen + " ) " + " / " + $numJointExprs + " ) ) " ) ) ;//works: accordian style, all joints spread evenly at any deploy value//expression -s ( ( $thisJointName + ".tz = ( " + ( $controlsArray[0] + ".deploy" ) + " / 100 ) " + " * ( " + $thisJointInit + " + ( ( " + $curveInfoNode + ".arcLength - " + $initClen + " ) " + " / " + $numJointExprs + " ) ) " ) ) ;//try to do successive spreading//pasted from script listener after execution...//expression -e -s "float $inc = ( 100.0 / 7 ) ;\r\nfloat $min = ( $inc * 2 ) ;\r\nfloat $max = ( $inc * 3 ) ;\r\n\r\nif ( ammoBeltR1_control.deploy < $min )\r\n{\r\n\tRigJoint_ammoBeltR7.translateZ = 0.01 ;\r\n}\r\nelse if ( ammoBeltR1_control.deploy > $max )\r\n{\r\n\tRigJoint_ammoBeltR7.translateZ = 9.217608326 ;\r\n}\r\nelse\r\n{\r\nfloat $bs = `getAttr ammoBeltR1_control.deploy` ;\r\nRigJoint_ammoBeltR7.translateZ = ( `linstep $min $max $bs` )  * ( 9.217608326 + ( ( curveInfo1.arcLength - 69.61793051 )  / 7 ) ) ;\r\n}"  -o "" -ae 1 -uc all  expression2;//works, is wrong tho: deploy order is reversed.  fixed the 'auto stretch' tho.//expression -s ( "float $inc = ( 100.0 / " + $numJointExprs + " ) ;\r\nfloat $min = ( $inc * " + ( $numJointExprs - $i -1 ) + " );\r\nfloat $max = ( $inc * " + ( $numJointExprs - $i ) + " ) ;\r\n\r\nif ( " + ( $controlsArray[0] + ".deploy" ) + " < $min )\r\n{\r\n\t" + $thisJointName + ".tz = 0.01 ;\r\n}\r\nelse if ( " + ( $controlsArray[0] + ".deploy" ) + " >= $max )\r\n{\r\n\t" + $thisJointName + ".tz = ( " + $thisJointInit + " + ( ( " + $curveInfoNode + ".arcLength - " + $initClen + " )  / " + $numJointExprs + " ) ) ;\r\n}\r\nelse\r\n{\r\nfloat $bs = `getAttr " + ( $controlsArray[0] + ".deploy" ) + "` ;\r\n" + $thisJointName + ".tz = ( `linstep $min $max $bs` )  * ( " + $thisJointInit + " + ( ( " + $curveInfoNode + ".arcLength - " + $initClen + " )  / " + $numJointExprs + " ) ) ;\r\n}" ) ;//works, yayexpression -s ( "float $inc = ( 100.0 / " + $numJointExprs + " ) ;\r\nfloat $min = ( $inc * " + ( $i  ) + " );\r\nfloat $max = ( $inc * " + ( $i + 1 ) + " ) ;\r\n\r\nif ( " + ( $controlsArray[0] + ".deploy" ) + " <= $min )\r\n{\r\n\t" + $thisJointName + ".tz = 0.01 ;\r\n}\r\nelse if ( " + ( $controlsArray[0] + ".deploy" ) + " >= $max )\r\n{\r\n\t" + $thisJointName + ".tz = ( " + $thisJointInit + " + ( ( " + $curveInfoNode + ".arcLength - " + $initClen + " )  / " + $numJointExprs + " ) ) ;\r\n}\r\nelse\r\n{\r\nfloat $bs = `getAttr " + ( $controlsArray[0] + ".deploy" ) + "` ;\r\n" + $thisJointName + ".tz = ( `linstep $min $max $bs` )  * ( " + $thisJointInit + " + ( ( " + $curveInfoNode + ".arcLength - " + $initClen + " )  / " + $numJointExprs + " ) ) ;\r\n}" ) ;}}}//print $hierarchyRig ;}  // Fin