// pass in zero for $cubeScale to not make the cubes that are parented to the joints
global proc string[] vstCreateSkeletonChain( string $prefix, string $nodeGroup, float $cubeScale )
{
	// duplicate the nodeGroup so that constraints for the shoulder and foot don't interfere
	$tmpNode = `duplicate $nodeGroup`;
	$nodeGroup = $tmpNode[0];

	// store the matrix of the $nodeGroup so it can be put back
	float $nodeGroupMatrix[16] = `xform -q -matrix $nodeGroup`;
	setAttr ( $nodeGroup + ".translateX" ) 0;
	setAttr ( $nodeGroup + ".translateY" ) 0;
	setAttr ( $nodeGroup + ".translateZ" ) 0;
	setAttr ( $nodeGroup + ".rotateX" ) 0;
	setAttr ( $nodeGroup + ".rotateY" ) 0;
	setAttr ( $nodeGroup + ".rotateZ" ) 0;

	// get the children of $nodeGroup
	string $nodes[] = `listRelatives -f -c -type transform $nodeGroup`;

	// get the positions of the locators and build the joint names
	string $jointNames[];
	string $cubeNames[];
	float $nodePos[];
	for ( $n in $nodes )
	{
		if ( `nodeType $n` == "transform" )
		{
			print ("node: " + $n + "\n");
			string $buffer[];
			tokenize $n "|" $buffer;
			$name = $buffer[size($buffer)-1];
			$jointNames[size($jointNames)] = ( $prefix + "_" + $name );
			$cubeNames[size($cubeNames)] = ( "cube_" + $name );
			float $tmpPos[] = `xform -q -ws -rp $n`;
			for ($t in $tmpPos)
			{
				$nodePos[size($nodePos)] = $t;
			}
		}
	}
	
	// build an array of bone lengths
	float $jointLengths[];
	for ($count = 0; $count < (size($nodes) - 1); $count++)
	{
		$nodePosCount = $count * 3;
		$jointLengths[$count] = mag(<<$nodePos[$nodePosCount], $nodePos[$nodePosCount + 1], $nodePos[$nodePosCount + 2]>> - <<$nodePos[$nodePosCount + 3], $nodePos[$nodePosCount + 4], $nodePos[$nodePosCount + 5]>>);
	}

	// create the first joint at the origin
	select -d;
	$jointNames[0] = `joint -p 0 0 0 -n $jointNames[0]`;

	// loop through the remaining joints to offset them by the correct $jointLength index
	for ($count = 1; $count < size($jointNames); $count++)
	{
		$jointNames[$count] = `joint -p 0 0 0 -n $jointNames[$count]`;
		xform -t 0 (-$jointLengths[$count -1]) 0 $jointNames[$count];
	}

	float $jointOffset = 0.0;
	float $jointLengthOffset = 0.0;
	for ($count = 0; $count < size($jointNames) - 1; $count++)
	{
		if ( $cubeScale )
		{
			//$cyl = `polyCylinder -axis 1 0 0 -height ( $cubeScale / .25 ) -radius ( $cubeScale / .25 )`;
			$cube = `polyCube -w $cubeScale -d $cubeScale -h 0 -n $cubeNames[$count]`;
			move -r 0 -.5 0 ($cube[0] + ".f[1]");
			move -r 0 (-$jointLengths[$count] + .5) 0 ($cube[0] + ".f[3]");
			$jointOffset += $jointLengths[$count];
			if ($count > 0)
			{
				//move 0 (-1 * ($jointLengths[$count-1] + $jointLengthOffset)) 0 $cyl[0];
				move 0 (-1 * ($jointLengths[$count-1] + $jointLengthOffset)) 0 $cube[0];
				$jointLengthOffset += $jointLengths[$count-1];
			}
			//parent $cyl[0] $jointNames[$count];
			parent $cube[0] $jointNames[$count];
		}
	}

	// create ik handles to position the joints where the guide has them
	string $ikHandles[];
	for ($count = 1; $count < size($jointNames); $count++)
	{
		$ik = `ikHandle -sol ikSCsolver -sj $jointNames[$count - 1] -ee $jointNames[$count]`;
		$ikHandles[$count - 1]  = $ik[0];
	}

	// place the first joint without using ik
	move -a $nodePos[0] $nodePos[1] $nodePos[2] $jointNames[0];

	// do the rest of the joints using ik
	for ($count = 1; $count < size($jointNames); $count++)
	{
		$nodePosCount = $count * 3;
		move -a $nodePos[$nodePosCount] $nodePos[$nodePosCount + 1] $nodePos[$nodePosCount + 2] $ikHandles[$count - 1];
	}

	// the last ik handle will sometimes move if the screen isn't refreshed before it gets deleted
	// there is probably a better way to do this that doesn't use the handles, but for now just force a refresh
	refresh;
	delete $ikHandles;

	// parent the joint chain to the guide group and return the guide to the original location
	parent $jointNames[0] $nodeGroup;
	xform -matrix 	$nodeGroupMatrix[0]  $nodeGroupMatrix[1]  $nodeGroupMatrix[2]  $nodeGroupMatrix[3]
					$nodeGroupMatrix[4]  $nodeGroupMatrix[5]  $nodeGroupMatrix[6]  $nodeGroupMatrix[7]
					$nodeGroupMatrix[8]  $nodeGroupMatrix[9]  $nodeGroupMatrix[10] $nodeGroupMatrix[11]
					$nodeGroupMatrix[12] $nodeGroupMatrix[13] $nodeGroupMatrix[14] $nodeGroupMatrix[15]
					$nodeGroup;
					
	// unparent the joints, and set the preferred angles
	parent -w $jointNames[0];
	joint -e -spa -ch $jointNames[0];

	// remove the duplicated $nodeGroup
	delete $nodeGroup;

	// add the current rotation values to the joint orient attribute, and set the rotations to zero
	// this will align the manipulator with the bone properly
	for($joint in $jointNames)
	{
		float $rx = `getAttr ($joint + ".rotateX")`;
		float $ry = `getAttr ($joint + ".rotateY")`;
		float $rz = `getAttr ($joint + ".rotateZ")`;

		float $jorx = `getAttr ($joint + ".jointOrientX")`;
		float $jory = `getAttr ($joint + ".jointOrientY")`;
		float $jorz = `getAttr ($joint + ".jointOrientZ")`;

		setAttr ($joint + ".jointOrientX") ($rx + $jorx);
		setAttr ($joint + ".jointOrientY") ($ry + $jory);
		setAttr ($joint + ".jointOrientZ") ($rz + $jorz);

		setAttr ($joint + ".rotateX") 0;
		setAttr ($joint + ".rotateY") 0;
		setAttr ($joint + ".rotateZ") 0;
	}
	return ($jointNames);

}
