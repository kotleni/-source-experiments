//*****************************************
//
//	vstDupeFKarm
//	-makes a duplicate three bone arm
//
//	use: vstDupeFKarm( side, joint1, joint2, joint3, type, vstInfo )
//	for example to make a duplicate right arm you would call this:
//	vstDupeFKarm( "R", "upperarm", "lowerarm", "wrist", "FK", vstInfo )
//
// 	by: steve/wade
//	stevek@valvesoftware.com
//	wade@valvesoftware.com
//	3/07/2006
//	5/18/2006
//		-passed in the vstInfo node so that channels can be locked/hidden/added to plotted
//
//******************************************

global proc string[] vstDupeFKarm( string $side, string $arm[], string $parent, float $radius, string $vstInfo )
{
	string $dupeArm[];
	select -cl;

	// name the new controllers
	string $newUp =  $arm[0] + "FK";
	string $newMid = $arm[1] + "FK";
	string $newEnd = $arm[2] + "FK";

	// use nurbs surfaces for the controls
	vstBoneToCylinder( $arm[0], $arm[1], $radius, $newUp );
	parent $newUp $parent;
	vstBoneToCylinder( $arm[1], $arm[2], $radius, $newMid );
	parent $newMid $newUp;
	sphere -r $radius -s 4 -nsp 2 -name $newEnd -ch 0 -po 0;
	// now stick/unstick newEnd to the "real" skeleton
	delete `parentConstraint  $arm[2] $newEnd`;
	parent $newEnd $newMid;

	vstMakeZero $newEnd;
	vstMakeZero $newUp;
	vstMakeZero $newMid;;

	// point constrain the new upper joint to the skeleton
	pointConstraint $arm[0] $newUp;

	// set its display color
	vstSetDisplay( $side, $newUp );

	// set up the constraints to drive the real skeleton
	string $upArmCons[] = `orientConstraint -mo -w 1 $newUp  $arm[0]`;
	// maya does not return the new attr name (and that is what we end up controlling)
	// so get the name by finding out what the last attr added to the object was
	string $num[] = `listAttr -v $upArmCons[0]`;
	int $size = size( $num );
	string $upArmConsAttr = $num[( $size -1 )];
	string $lowArmCons[] = `orientConstraint -mo -w 1 $newMid $arm[1]`;
	string $num[] = `listAttr -v $lowArmCons[0]`;
	int $size = size( $num );
	string $lowArmConsAttr = $num[( $size -1 )];

 	string $upWeight = $upArmCons[0] + "." + $upArmConsAttr;
	string $lowWeight = $lowArmCons[0] + "." + $lowArmConsAttr;

	// hook up the constraint weights to the main ik/fk switch
	string $switchAttr = ( "main." + $side + "ArmIKFK" );
	string $visAttr = ( $newUp + ".visibility" );
	int $isFK = `gmatch $newUp "*FK*"`;

	// set up expressions to set up the FK as the opposite of the IK weight
	string $FKupArmExp = ( $upWeight + "= 1 - "+ $switchAttr );
	expression -s $FKupArmExp -n ($newUp + "swtichExp" );
	string $FKlowArmExp = ( $lowWeight + "= 1 - "+ $switchAttr );
	expression -s $FKlowArmExp -n ( $newMid + "switchExp" );
	//set up visibility expressions, only show FK bones when they have a value
	string $visExp = "if( " + $switchAttr + "==1 )\r\n" + $visAttr + "=0;\r\nelse\r\n" + $visAttr + "=1;";
	expression -s $visExp -n ( $newUp + "visExp" );

	$dupeArm[0] = $newUp;
	$dupeArm[1] = $newMid;
	$dupeArm[2] = $newEnd;

	vstInfoAttr( ($side + "FKshoulder"), $dupeArm[0], $vstInfo);
	vstInfoAttr( ($side + "FKelbow"), $dupeArm[1], $vstInfo);
	vstInfoAttr( ($side + "FKwrist"), $dupeArm[2], $vstInfo);
	for ($bone in $dupeArm)
	{
		vstHideChannels ($bone, { ".tx", ".ty", ".tz", ".sx", ".sy", ".sz", ".v" } );
		vstSelectHandle ($bone, 0, 0, 0);
		vstAddPlotted ($bone);
	}
	vstHideChannels ($dupeArm[1], {".ry", ".rz"});


	// return all the new joints
	return $dupeArm;

}