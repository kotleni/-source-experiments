//
//script for creating an IK driven leg
//

global proc string[] vstCreatePuppetLeg(string $name, string $hipNode, string $kneeNode, string $heelNode, string $toeNode)
{

	string $prefix = $name;
	// Take the given nodes and prefix and generate an inverse foot controlled leg
	// structure.  When finished, return the root node of the leg (in this
	// case, the hip joint.

	// VARIABLES
	string $hipJoint, $kneeJoint, $heelJoint, $toeJoint;
	float  $hipPos[3], $kneePos[3], $heelPos[3], $toePos[3];

	// first create the strings we're going to be using
	$hipJoint = ("Bip01_" + $prefix + "_Thigh");
	$kneeJoint = ("Bip01_" + $prefix + "_Calf");
	$heelJoint = ("Bip01_" + $prefix + "_Foot");
	$toeJoint = ("Bip01_" + $prefix + "_Toe");
	$toeEndJoint = ($prefix + "_toe_null");

	// get the positions of the locators
	$hipPos = `xform -q -ws -rp  ($hipNode )`;
	$kneePos = `xform -q -ws -rp  ($kneeNode )`;
	$heelPos = `xform -q -ws -rp  ($heelNode )`;
	$toePos = `xform -q -ws -rp  ($toeNode )`;
	
	// get the lengths of the bones.
	float $thighDist = mag(<<$hipPos[0], $hipPos[1], $hipPos[2]>> - <<$kneePos[0], $kneePos[1], $kneePos[2]>>);
	float $calfDist = mag(<<$kneePos[0], $kneePos[1], $kneePos[2]>> - <<$heelPos[0], $heelPos[1], $heelPos[2]>>);
	float $footDist = mag(<<$heelPos[0], $heelPos[1], $heelPos[2]>> - <<$toePos[0], $toePos[1], $toePos[2]>>);

	// create hip joint
	select -d;	
	$hipJoint = `joint -p 0 0 0 -n $hipJoint`;
	
	// create knee joint
	$kneeJoint = `joint -p 0 0 0 -n $kneeJoint`;
	xform -t 0 (-$thighDist) 0 $kneeJoint;
	joint -e -zso -oj yzx $kneeJoint;

	// rotate the hip out temporarily to make the IK work properly
	setAttr  ($hipJoint + ".rotateX") -45;

	// create heel joint
	$heelJoint = `joint -p 0 0 0 -n $heelJoint`;
	xform -t 0 (-$calfDist) 0 $heelJoint;
	joint -e -zso -oj yzx $heelJoint;

	// rotate the hip out temporarily to make the IK work properly
	setAttr  ($kneeJoint + ".rotateX") 45;	

	// create toe joint
	$toeJoint = `joint -p 0 0 0 -n $toeJoint`;
	xform -t 0 (-$footDist) 0 $toeJoint;
	joint -e -zso -oj yzx $toeJoint;

	// create the end of the toe. It's 1/2 the position from the heel to the toe and not really needed.
	float $toeTipdist = mag(<<$heelPos[0], $heelPos[1], $heelPos[2]>> - <<$toePos[0], $toePos[1], $toePos[2]>>);
	float $toeLength = $toeTipdist/1.5;
	select $toeJoint;
	$toeEndJoint = `joint -p 0 0 0 -n $toeEndJoint`;
	xform -t 0 (-$toeLength) 0 $toeEndJoint;
	joint -e -zso -oj yzx $toeEndJoint;

	// rotate the hip out temporarily to make the IK work properly
	setAttr  ($heelJoint + ".rotateX") -90;	
	setAttr  ($toeJoint + ".rotateX") -45;	
	setAttr  ($kneeJoint + ".rotateX") 90;	

	// set the prefered joint angles.
	joint -e -spa -ch  $hipJoint ;
	joint -e -spa -ch  $kneeJoint ;
	joint -e -spa -ch  $heelJoint ;
	joint -e -spa -ch  $toeJoint ;

	// temporarily controls to be on the bones
	select $hipJoint $hipNode ;
	$pc = `pointConstraint`;
	delete $pc;

	select $kneeJoint $kneeNode ;
	$pc = `pointConstraint`;
	delete $pc;

	select $heelJoint $heelNode ;
	$pc = `pointConstraint`;
	delete $pc;

	select $toeJoint $toeNode ;
	$pc = `pointConstraint`;
	delete $pc;

	// Create the IkHandles for the legs
	$legHandle = `ikHandle -sol ikRPsolver -sj $hipJoint -ee $heelJoint -n ($prefix + "_legHandle")`;	
	$heelHandle = `ikHandle -sol ikRPsolver -sj $heelJoint -ee $toeJoint -n ($prefix + "_heelHandle")`;
	$toeHandle = `ikHandle -sol ikRPsolver -sj $toeJoint -ee $toeEndJoint -n ($prefix + "_toeHandle")`;

	// create the groups necessary to do the inverse foot thing.  In this case we need two "ball"
	// groups, a single end of the toe group, and that should be it.
	$dup = `duplicate $toeNode`;
	$toeWiggleNode = `rename ($dup[0]) ($prefix + "_wiggle")`;
	$dup = `duplicate $toeNode`;
	$toeEndNode = `rename ($dup[0]) ($prefix + "_end")`;

	// move the toeEndNode to the location of toeEndJoint
	select $toeEndJoint $toeEndNode;
	$pc = `pointConstraint`;
	delete $pc;
	
	// parent everything so it's all nice and working smooth
	parent -a $toeHandle[0] $toeWiggleNode;
	parent -a $heelHandle[0] $toeNode;
	parent -a $legHandle[0] $toeNode;
	parent -a $toeNode $toeWiggleNode $toeEndNode;
	parent -a $toeEndNode $heelNode;
	
	// create the poleVectorControl
	select $kneeNode $legHandle[0] ;
	poleVectorConstraint;	

	// Add all the foot control attributes
	addAttr -ln "ballLift" -at double $heelNode;
	addAttr -ln "toeLift" -at double $heelNode;
	addAttr -ln "toeWiggle" -at double $heelNode;
	addAttr -ln "toeTwist" -at double $heelNode;

	setAttr -k 1 ($heelNode + ".ballLift");
	setAttr -k 1 ($heelNode + ".toeLift");
	setAttr -k 1 ($heelNode + ".toeWiggle");
	setAttr -k 1 ($heelNode + ".toeTwist");

	// Connect the attributes
	connectAttr ($heelNode + ".ballLift") ($toeNode + ".rx");
	connectAttr ($heelNode + ".toeLift") ($toeEndNode + ".rx");
	connectAttr ($heelNode + ".toeWiggle") ($toeWiggleNode + ".rx");
	connectAttr ($heelNode + ".toeTwist") ($toeEndNode + ".ry");
	
	// Create duplicate foot controls that the toeEndNode can go under
	$dup = `duplicate $heelNode`;
	$heelDupNode = `rename $dup[0] ($heelNode + "_const")`;
	delete `listRelatives -f -c $heelDupNode`;
	parent $toeEndNode $heelDupNode;
	select $heelNode $heelDupNode;
	pointConstraint; orientConstraint;
	
	// constrain the hips
	select $hipNode $hipJoint;
	pointConstraint;
	
	// return controls to their original positions
	move -a $hipPos[0] $hipPos[1] $hipPos[2] $hipNode;
	move -a $kneePos[0] $kneePos[1] $kneePos[2] $kneeNode;
	move -a $heelPos[0] $heelPos[1] $heelPos[2] $heelNode;
	move -a $toePos[0] $toePos[1] $toePos[2] $toeNode;

	// set the ballLift attribute to place joints at the controls
	// $toeNode is a transform, so pointPosition won't work	
	float $toeCurrentPos[] = `xform -q -ws -t $toeJoint`;
	float $ankleCurrentPos[] = `xform -q -ws -t $heelJoint`;
	float $ankleTargetPos[] = `xform -q -t $heelNode`;
	
	float $currentV[];
	$currentV[0] = $ankleCurrentPos[0] - $toeCurrentPos[0];
	$currentV[1] = $ankleCurrentPos[1] - $toeCurrentPos[1];
	$currentV[2] = $ankleCurrentPos[2] - $toeCurrentPos[2];
	
	float $targetV[];
	$targetV[0] = $ankleTargetPos[0] - $toeCurrentPos[0];
	$targetV[1] = $ankleTargetPos[1] - $toeCurrentPos[1];
	$targetV[2] = $ankleTargetPos[2] - $toeCurrentPos[2];

	// doing this all on one line seems to error unless the script is sourced once:
	// float $setBallLift = `rad_to_deg( acos( dotProduct( $targetV, $currentV, true ) ) )`;
	float $setBallLiftDot = dotProduct( $targetV, $currentV, true );
	float $setBallLiftAcos = acos( $setBallLiftDot );
	float $setBallLift = `rad_to_deg( $setBallLiftAcos )`;
	
	setAttr ($heelNode + ".ballLift") (-1 * $setBallLift);

	string $stuff[] = {
		(""+$heelDupNode+"")
	};
	vstHideUnnecessary $stuff;
	
	string $outLegArray[] =
	{
		$hipJoint,
		$hipNode,
		$kneeNode,
		$heelNode
	};

	// move the end of the toe joint to be at the same height as the ball
	select -r $toeHandle;
	move -rpr -y $toePos[1];

	print ("=== leg created: " + $name + "\n\t" + $hipJoint + "\n\t" + $hipNode + "\n\t" + $kneeNode + "\n\t" + $heelNode + "\n");
	return ($outLegArray);

}
