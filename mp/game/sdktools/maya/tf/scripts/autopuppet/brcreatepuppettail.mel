// brCreatePuppetSpine back $tailNode $pelvisNode $numJoints;
//
// file -f -new;
// spaceLocator -p 0 0 0;
// spaceLocator -p 0 0 0;
// setAttr "locator2.translateY" 1;
// source brCreatePuppetSpine;
// brCreatePuppetSpine back locator1 locator2 6;
// 

global proc string[] differenceStringArrays (string $array1[], string $array2[])
{
	string $x;
	string $y;
	string $newArray[];
	string $flatArray[];
	int $itemFound = 0;


	//...find items in array1 that don't appear in array2
	for ($x in $array1)
	{
		$itemFound = 0;
		for ($y in $array2)
		{
			if ($x == $y) {$itemFound = 1;}
		}
		if ($itemFound == 0) {$newArray[size($newArray)] = $x;}
	}


	//...find items in array2 that don't appear in array1
	for ($x in $array2)
	{
		$itemFound = 0;
		for ($y in $array1)
		{
			if ($x == $y) {$itemFound = 1;}
		}
		if ($itemFound == 0) {$newArray[size($newArray)] = $x;}
	}


	//...flatten the result
	$flatArray[0] = $newArray[0];
	for ($x in $newArray)
	{
		$itemFound = 0;
		for ($y in $flatArray)
		{
			if ($x == $y) {$itemFound = 1;}
		}
		if ($itemFound == 0) {$flatArray[size($flatArray)] = $x;}
	}

	return ($flatArray);
}

global proc string[] addStringArrays (string $array1[], string $array2[])
{
	string $x;

	//...add the two arrays together
	for ($x in $array2)
	{
		$array1[size($array1)] = $x;
	}

	return ($array1);
}


global proc string[] brCreatePuppetTail (string $name, string $direction, string $pelvis, string $tailTip, int $numJoints, int $numFKCntrls)
{

	if ((`gmatch $direction "z"`) || (`gmatch $direction "y"`) || (`gmatch $direction "-y"`) || (`gmatch $direction "-z"`)) 
	{

		select -cl;

		// create names
		string $tailName = $name;
		string $root = ($tailName + "_root");
		string $tailRoot = ($tailName + "_1");
		string $tailEnd  = ($tailName + "_" + ( $numJoints -1 ));
		string $tailFinalJoint = ($tailName + "_" + ( $numJoints + 1 ));

		// get pelvis initial location
		float $pelvisPos[] = `getAttr ($pelvis + ".translate")`;
		float $pelvisRot[] = `getAttr ($pelvis + ".rotate")`;

		// get tail initial location
		float $tailPos[] = `getAttr ($tailTip+ ".translate")`;	
		float $tailRot[] = `getAttr ($tailTip+ ".rotate")`;

		// get pelvis initial location
		float $tailRootPos[] = `getAttr ($pelvis + ".translate")`;
		float $tailRootRot[] = `getAttr ($pelvis + ".rotate")`;

		//get the initial length of the tail
		float $dist = mag(<<$pelvisPos[0], $pelvisPos[1], $pelvisPos[2]>> - <<$tailPos[0], $tailPos[1], $tailPos[2]>>);

		//set the initial bone length
		float $jLength = $dist / $numJoints ;

		// create the wrapper nodes
  		string $tailWrapper   = ($name + "_tailWrapper");
		string $tailNameGroup = ($tailName + "_group");	
		createNode transform -n $tailNameGroup ;

		// create skeleton joints.
		select -cl;
		if (`gmatch $direction "y"`) 
		{
			// create tail skeleton joints.
			int $num = 1;
			while ($num < ($numJoints + 1 ))
			{

				// create the joints
				string $jname = ($tailName+ "_" + ($num - 1));
				joint -p 0 ($jLength * $num) 0 -name $jname;
				joint -e -zso -oj xzy $jname;
				$num++;

			}
			rename ($tailName+ "_0") $root;
		}
		if (`gmatch $direction "z"`) 
		{
			// create tail skeleton joints.
			int $num = 1;
			while ($num < ($numJoints + 1))
			{

				// create the joints
				string $jname = ($tailName+ "_" + ($num - 1));
				joint -p 0 0 ($jLength * $num) -name $jname;
				joint -e -zso -oj xyz -roo xyz $jname;
				$num++;

			}
			rename ($tailName+ "_0") $root;
		}
		if (`gmatch $direction "-z"`) 
		{
			// create tail skeleton joints.
			int $num = 1;
			while ($num < ($numJoints + 1))
			{

				// create the joints
				string $jname = ($tailName+ "_" + ($num - 1));
				joint -p 0 0 ($jLength * ( - $num )) -name $jname;
				joint -e -zso -oj xyz -roo xyz $jname;
				$num++;
			}
			rename ($tailName+ "_0") $root;
		}
		string $tmpPelvis[]  = `duplicate -rr $pelvis`;
		parent -r $root $tmpPelvis[0];
		
		// orient tail correctly
		select -r $tailTip $tmpPelvis[0];
		if (`gmatch $direction "z"`)
		{
			$tmpPntConB = `aimConstraint -weight 1 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "scene"`;
		}
		
		if (`gmatch $direction "-z"`)
		{
			$tmpPntConB = `aimConstraint -weight 1 -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "scene"`;
		}
		if (`gmatch $direction "y"`) 
		{
			$tmpPntConB = `aimConstraint -weight 1 -aimVector 0 1 0 -upVector 0 1 0 -worldUpType "scene"`;
		}
		if (`gmatch $direction "-y"`) 
		{
			$tmpPntConB = `aimConstraint -weight 1 -aimVector 0 -1 0 -upVector 0 1 0 -worldUpType "scene"`;
		}
		parent -a -w $root;
		delete $tmpPelvis[0];	


		// move the tailTip locator to the root
		select -r $root $tailTip ;
		string $tmp[] = `pointConstraint -weight 1`;
		delete $tmp[0];
		
		// now point and orient the root back to the tailTip
		select -r $tailTip $root;
		string $TPC[] = `pointConstraint -weight 1`;
		parent $TPC $tailNameGroup;
		select -r $tailTip $root;
		string $TOC[] = `orientConstraint -weight 1`;
		parent $TOC $tailNameGroup;
		
		// create tail FK locators
		int $num = 1;
		int $numFKCntrl = $numJoints / $numFKCntrls ;
		string $controlJoints[];
		while ($num < ($numFKCntrl ))
		{
			string $lastBuf[] = $controlJoints;
			string $tailCont = ($name + "_FK_" + $num);
			string $relJoint = (($tailName+ "_" + (($num * $numFKCntrls) - 1 )));
			createNode transform -n $tailCont;
			setAttr ($tailCont + ".displayHandle") 1;
			parent -r $tailCont $relJoint;
			parent -w -a $tailCont;
			
			// setup the constriants
			select -r $tailCont $relJoint;
			//string $Oc[] = `orientConstraint -weight 1 `;
			connectAttr -f ($tailCont + ".rotate") ($relJoint +".rotate");
			
			select -r $relJoint $tailCont;
			string $Pc[] = `pointConstraint -weight 1 `;
			
			//parent -a $tailCont $tailTip;
			
			//parent $Oc[0] $Pc[0] $tailNameGroup;
			parent $Pc[0] $tailNameGroup;

			$num++;
			string $curBuf[] = { $relJoint };
			$controlJoints = `addStringArrays $curBuf $lastBuf`;
		}
		
		// connect each joints rotation to its parent
		string $tailJoints[] = `listRelatives -ad $root`;
		string $slaveTailJoints[] = `differenceStringArrays $tailJoints $controlJoints`;
		for ($joint in $slaveTailJoints)
		{
			//get the parent joint
			string $parentJoints[] = `listRelatives -p $joint`;
			
			//now connect the .r to its parent
			if (!`gmatch $joint $root` )
			{
				if (!`connectionInfo -ied ( $joint + ".rotate")`)
				{
					connectAttr -f ($parentJoints[0] + ".rotate") ($joint +".rotate");
				}
			}
		}

		// get the rotation from the root joint and rotate the tail control by the invers amount.
		// this is a hack, but to fix I need to rethink.  might be the best way to do it.
		float $valRot[3];
		$valRot = `getAttr ($root + ".rotate")`;
		setAttr ($tailTip + ".rotate") (- $valRot[0]) (- $valRot[1]) (- $valRot[2]);

		parent -a $tailTip $tailNameGroup;

		//return $tailChest;
		string $outArray[] = {
			$root,
			$tailNameGroup
		};
		print ("::: " + $name + " tail created \!\! \n");
		return ($outArray);
	}
	else
	{
		error "you must choose z or y as the tail's major orientation";
	}
}

